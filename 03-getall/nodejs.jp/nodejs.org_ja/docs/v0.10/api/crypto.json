{
  "source": "doc/api/crypto.markdown",
  "modules": [
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "desc": "<!--\n    Stability: 2 - Unstable; API changes are being discussed for\n    future versions.  Breaking changes will be minimized.  See below.\n-->\n\n<pre><code>Stability: 2 - Unstable; 将来のバージョンにおいて API の変更が\n議論されています。互換性を損なう変更は最小限になる予定です。\n後述します。</code></pre>\n<!--\nUse `require('crypto')` to access this module.\n-->\n\n<p>このモジュールにアクセスするには <code>require(&#39;crypto&#39;)</code> を使用します。\n\n</p>\n<!--\nThe crypto module offers a way of encapsulating secure credentials to be\nused as part of a secure HTTPS net or http connection.\n-->\n\n<p>暗号化モジュールは安全な HTTPS ネットワークや http\nコネクションの一部として使われる、\n安全な認証情報をカプセル化する方法を提供します。\n\n</p>\n<!--\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher,\ndecipher, sign and verify methods.\n-->\n\n<p>同時に OpenSSL のハッシュ、HMAC、暗号、復号、署名、そして検証へのラッパーを一式提供します。\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "crypto.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "desc": "<!--\nReturns an array with the names of the supported ciphers.\n-->\n\n<p>サポートされている暗号の名前からなる配列を返します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var ciphers = crypto.getCiphers();\nconsole.log(ciphers); // [&#39;AES-128-CBC&#39;, &#39;AES-128-CBC-HMAC-SHA1&#39;, ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.getHashes()",
          "type": "method",
          "name": "getHashes",
          "desc": "<!--\nReturns an array with the names of the supported hash algorithms.\n-->\n\n<p>サポートされているハッシュアルゴリズムの名前からなる配列を返します。\n\n</p>\n<!--\nExample:\n-->\n\n<pre><code>var hashes = crypto.getHashes();\nconsole.log(hashes); // [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.createCredentials(details)",
          "type": "method",
          "name": "createCredentials",
          "desc": "<!--\nCreates a credentials object, with the optional details being a\ndictionary with keys:\n-->\n\n<p>認証情報オブジェクトを作成します。オプションの <code>details</code>\nは以下のキーを持つ辞書です:\n\n</p>\n<!--\n* `pfx` : A string or buffer holding the PFX or PKCS12 encoded private\n  key, certificate and CA certificates\n* `key` : A string holding the PEM encoded private key\n* `passphrase` : A string of passphrase for the private key or pfx\n* `cert` : A string holding the PEM encoded certificate\n* `ca` : Either a string or list of strings of PEM encoded CA\n  certificates to trust.\n* `crl` : Either a string or list of strings of PEM encoded CRLs\n  (Certificate Revocation List)\n* `ciphers`: A string describing the ciphers to use or exclude.\n  Consult\n  <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT>\n  for details on the format.\n-->\n\n<ul>\n<li><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、および CA の\n証明書を含む文字列またはバッファ。</li>\n<li><code>key</code> : PEM でエンコードされた秘密鍵を保持する文字列。</li>\n<li><code>passphrase</code>: 秘密鍵または pfx のパスフレーズ。</li>\n<li><code>cert</code> : PEM でエンコードされた証明書を保持する文字列。</li>\n<li><code>ca</code> : 信頼できる認証局の証明書が PEM でエンコードされた文字列または\n文字列の配列。</li>\n<li><code>crl</code> : PEM でエンコードされた CRL (Certificate Revocation List、\n失効した証明書の一覧) の文字列または文字列の配列。</li>\n<li><code>ciphers</code>: 使用または除外する暗号を記述した文字列。\n詳細は <a href="\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\"">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\nを参照してください。</li>\n</ul>\n<!--\nIf no 'ca' details are given, then node.js will use the default\npublicly trusted list of CAs as given in\n<http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.\n-->\n\n<p>&#39;ca&#39; の詳細が与えられなかった場合、node.js はデフォルトとして\n</p>\n<p><a href="\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\"">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>\nで与えられる、信頼できる認証局の公開されたリストを使用します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHash(algorithm)",
          "type": "method",
          "name": "createHash",
          "desc": "<!--\nCreates and returns a hash object, a cryptographic hash with the given\nalgorithm which can be used to generate hash digests.\n-->\n\n<p>ハッシュオブジェクトを生成して返します。\n与えられたアルゴリズムによる暗号ハッシュ関数はダイジェストの生成に使われます。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are `'sha1'`, `'md5'`,\n`'sha256'`, `'sha512'`, etc.  On recent releases, `openssl\nlist-message-digest-algorithms` will display the available digest\nalgorithms.\n-->\n\n<p><code>algorithm</code> は、プラットフォーム上の OpenSSL \nのバージョンでサポートされている利用可能なアルゴリズムに依存します。\n例えば <code>&#39;sha1&#39;</code>、<code>&#39;md5&#39;</code>、<code>&#39;sha256&#39;</code>、<code>&#39;sha512&#39;</code>、などです。\n最近のリリースでは、<code>openssl list-message-digest-algorithms</code>\nで利用可能なダイジェストアルゴリズムが表示されます。\n\n</p>\n<!--\nExample: this program that takes the sha1 sum of a file\n-->\n\n<p>例: このプログラムはファイルのsha1ハッシュ値を求めます。\n\n</p>\n<pre><code>var filename = process.argv[2];\nvar crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar shasum = crypto.createHash(&#39;sha1&#39;);\n\nvar s = fs.ReadStream(filename);\ns.on(&#39;data&#39;, function(d) {\n  shasum.update(d);\n});\n\ns.on(&#39;end&#39;, function() {\n  var d = shasum.digest(&#39;hex&#39;);\n  console.log(d + &#39;  &#39; + filename);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHmac(algorithm, key)",
          "type": "method",
          "name": "createHmac",
          "desc": "<!--\nCreates and returns a hmac object, a cryptographic hmac with the given\nalgorithm and key.\n-->\n\n<p>与えられたアルゴリズムとキーで HMAC を計算する、HMAC オブジェクトを作成して返します。\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hmac.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by\nOpenSSL - see createHash above.  `key` is the hmac key to be used.\n-->\n\n<p><code>algorithm</code> は OpenSSL でサポートされているアルゴリズムに依存します － \n前述の <code>createHash</code> を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipher(algorithm, password)",
          "type": "method",
          "name": "createCipher",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm and\npassword.\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する暗号オブジェクトを作成して返します。\n<!--\n`algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc.  On\nrecent releases, `openssl list-cipher-algorithms` will display the\navailable cipher algorithms.  `password` is used to derive key and IV,\nwhich must be a `'binary'` encoded string or a [buffer](buffer.html).\n-->\n\n</p>\n<p><code>algorithm</code> は、OpenSSL に依存します。例えば <code>&#39;aes192&#39;</code> などです。\n最近のリリースでは、<code>openssl list-cipher-algorithms</code>\nで利用可能な暗号アルゴリズムが表示されます。\n<code>password</code> はキーと IV の生成に使用されます。\nこれは <code>&#39;binary&#39;</code> でエンコードされた文字列または <a href="\"buffer.html\"">buffer</a>\nでなければなりません\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed hash\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createCipheriv",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm, key and\niv.\n-->\n\n<p>与えられたアルゴリズムとキーおよび IV を使用する暗号オブジェクトを作成して\n返します。\n\n</p>\n<!--\n`algorithm` is the same as the argument to `createCipher()`.  `key` is\nthe raw key used by the algorithm.  `iv` is an [initialization\nvector](http://en.wikipedia.org/wiki/Initialization_vector).\n-->\n\n<p><code>algorithm</code> は <code>createCipher()</code> の引数と同じです。\n<code>key</code> はアルゴリズムで使用される生のキーです。\n<code>iv</code> は<a href="\"http://en.wikipedia.org/wiki/Initialization_vector\"">initialization\nvector</a> です。\n\n</p>\n<!--\n`key` and `iv` must be `'binary'` encoded strings or\n[buffers](buffer.html).\n-->\n\n<p><code>key</code> と <code>iv</code> は <code>&#39;binary&#39;</code> でエンコードされた文字列または\n<a href="\"buffer.html\"">buffers</a> でなければなりません\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipher(algorithm, password)",
          "type": "method",
          "name": "createDecipher",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm and\nkey.  This is the mirror of the [createCipher()][] above.\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipher()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createDecipheriv",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm, key\nand iv.  This is the mirror of the [createCipheriv()][] above.\n-->\n\n<p>与えられたアルゴリズムとキー、IV を使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipheriv()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createSign(algorithm)",
          "type": "method",
          "name": "createSign",
          "desc": "<!--\nCreates and returns a signing object, with the given algorithm.  On\nrecent OpenSSL releases, `openssl list-public-key-algorithms` will\ndisplay the available signing algorithms. Examples are `'RSA-SHA256'`.\n-->\n\n<p>与えられたアルゴリズムで署名オブジェクトを作成して返します。\n最近のOpenSSLのリリースでは、<code>openssl list-public-key-algorithms</code>\nで利用可能な署名アルゴリズムの一覧が表示されます。例えば &#39;RSA-SHA256&#39;。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createVerify(algorithm)",
          "type": "method",
          "name": "createVerify",
          "desc": "<!--\nCreates and returns a verification object, with the given algorithm.\nThis is the mirror of the signing object above.\n-->\n\n<p>与えられたアルゴリズムで検証オブジェクトを作成して返します。これは前述の署名オブジェクトと鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime_length)",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object and generates a prime of\nthe given bit length. The generator used is `2`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有オブジェクトを作成し、\n与えられた長さの素数を生成します。生成元は <code>2</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime_length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime, [encoding])",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object using the supplied prime.\nThe generator used is `2`. Encoding can be `'binary'`, `'hex'`, or\n`'base64'`.  If no encoding is specified, then a buffer is expected.\n-->\n\n<p>与えられた素数からディフィー・ヘルマン鍵共有オブジェクトを作成します。\n生成元は <code>2</code> です。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.getDiffieHellman(group_name)",
          "type": "method",
          "name": "getDiffieHellman",
          "desc": "<!--\nCreates a predefined Diffie-Hellman key exchange object.  The\nsupported groups are: `'modp1'`, `'modp2'`, `'modp5'` (defined in [RFC\n2412][]) and `'modp14'`, `'modp15'`, `'modp16'`, `'modp17'`,\n`'modp18'` (defined in [RFC 3526][]).  The returned object mimics the\ninterface of objects created by [crypto.createDiffieHellman()][]\nabove, but will not allow to change the keys (with\n[diffieHellman.setPublicKey()][] for example).  The advantage of using\nthis routine is that the parties don't have to generate nor exchange\ngroup modulus beforehand, saving both processor and communication\ntime.\n-->\n\n<p>事前に定義された Diffie-Hellman 鍵交換オブジェクトを作成します。\nサポートされるグループは、<code>&#39;modp1&#39;</code>, <code>&#39;modp2&#39;</code>, <code>&#39;modp5&#39;</code>\n([RFC 2412][] で定義される)、\nおよび <code>&#39;modp14&#39;</code>, <code>&#39;modp15&#39;</code>, <code>&#39;modp16&#39;</code>, <code>&#39;modp17&#39;</code>, <code>&#39;modp18&#39;</code>\n([RFC 3526][] で定義される) です。\n返されるオブジェクトは、前述の\n[crypto.createDiffieHellman()][]\nによって作成されたオブジェクトのインタフェースを模倣します。\nしかし、\n(たとえば [diffieHellman.setPublicKey()][] で)\n鍵を交換することはできません。\nこのルーチンを使うことによるアドバンテージは、\n事前にグループ係数を生成することも交換する必要もないため、\n処理と通信の時間を共に節約できることです。\n\n</p>\n<!--\nExample (obtaining a shared secret):\n-->\n\n<p>例 (共有鍵を取得):\n\n</p>\n<pre><code>var crypto = require(&#39;crypto&#39;);\nvar alice = crypto.getDiffieHellman(&#39;modp5&#39;);\nvar bob = crypto.getDiffieHellman(&#39;modp5&#39;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "group_name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, callback)",
          "type": "method",
          "name": "pbkdf2",
          "desc": "<!--\nAsynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments `(err, derivedKey)`.\n-->\n\n<p>疑似乱数を HMAC-SHA1 関数に適用して、与えられたパスワードと salt \n(ランダムなバイト値)、および繰り返しから、指定された長さの鍵を生成する、\n非同期の PBKDF2 です。\nコールバック関数は二つの引数を受け取る <code>(err, derivedKey)</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2Sync(password, salt, iterations, keylen)",
          "type": "method",
          "name": "pbkdf2Sync",
          "desc": "<!--\nSynchronous PBKDF2 function.  Returns derivedKey or throws error.\n-->\n\n<p>同期版の PBKDF2 関数。\n生成された鍵を返すか、例外をスローします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.randomBytes(size, [callback])",
          "type": "method",
          "name": "randomBytes",
          "desc": "<!--\nGenerates cryptographically strong pseudo-random data. Usage:\n-->\n\n<p>暗号学的で、強い疑似乱数データを生成します。使用法:\n\n</p>\n<pre><code>// async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n});\n\n// sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\n} catch (ex) {\n  // handle error\n  // most likely, entropy sources are drained\n}</code></pre>\n<!--\nNOTE: Will throw error or invoke callback with error, if there is not enough\naccumulated entropy to generate cryptographically strong data. In other words,\n`crypto.randomBytes` without callback will not block even if all entropy sources\nare drained.\n-->\n\n<p>注意: もし暗号理論的に強いデータを生成するために十分な累積エントロピーが\nなければ、エラーがスローされるか、エラーと共にコールバックが呼ばれます。\n言い換えると、コールバックを渡さずに <code>crypto.randomBytes()</code> を呼び出しても、\n全てのエントロピー源が枯渇するまでブロックするわけではありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pseudoRandomBytes(size, [callback])",
          "type": "method",
          "name": "pseudoRandomBytes",
          "desc": "<!--\nGenerates *non*-cryptographically strong pseudo-random data. The data\nreturned will be unique if it is sufficiently long, but is not\nnecessarily unpredictable. For this reason, the output of this\nfunction should never be used where unpredictability is important,\nsuch as in the generation of encryption keys.\n-->\n\n<p>暗号学的では <em>ない</em>、強い疑似乱数データを生成します。\n返されるデータは十分に長ければユニークですが、\n必ずしも予測不可能ではありません。\nこの理由のため、この関数の出力を暗号化キーの生成など、予測不可能であることが\n重要なところでは決して使用しないでください。\n\n</p>\n<!--\nUsage is otherwise identical to `crypto.randomBytes`.\n-->\n\n<p>他の使い方は <code>crypto.randomBytes</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "desc": "<!--\nThe class for creating hash digests of data.\n-->\n\n<p>データのハッシュダイジェストを作成するためのクラスです。\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed hash\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n<!--\nReturned by `crypto.createHash`.\n-->\n\n<p><code>crypto.createHash()</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hash.update(data, [input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the hash content with the given `data`, the encoding of which\nis given in `input_encoding` and can be `'utf8'`, `'ascii'` or\n`'binary'`.  If no encoding is provided and the input is a string an\nencoding of `'binary'` is enforced. If `data` is a `Buffer` then\n`input_encoding` is ignored.\n-->\n\n<p>与えられた <code>data</code> でハッシュの内容を更新します。\nそのエンコーディングは <code>input_encoding</code> で与えられ、<code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code>、\nまたは <code>&#39;binary&#39;</code> を指定することができます。\n<code>data</code> が文字列でエンコーディングが与えられなかった場合は、エンコーディングは\n<code>&#39;binary&#39;</code> が強制されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>これは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to be hashed.  The\n`encoding` can be `'hex'`, `'binary'` or `'base64'`.  If no encoding\nis provided, then a buffer is returned.\n-->\n\n<p>渡された全てのデータがハッシュ化されたダイジェストを計算します。\n<code>encoding</code> は <code>&#39;hex&#39;</code>、<code>&#39;binary&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `hash` object can not be used after `digest()` method has been\ncalled.\n-->\n\n<p>注意: <code>digest()</code> メソッドが呼び出された後で <code>hash</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<!--\nClass for creating cryptographic hmac content.\n\nReturned by `crypto.createHmac`.\n-->\n\n<p>hmac を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createHamc</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hmac.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdate the hmac content with the given `data`.  This can be called\nmany times with new data as it is streamed.\n-->\n\n<p>与えられた <code>data</code> で HMAC の内容を更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to the hmac.  The\n`encoding` can be `'hex'`, `'binary'` or `'base64'`.  If no encoding\nis provided, then a buffer is returned.\n-->\n\n<p>渡された全てのデータが HMAC 化されたダイジェストを計算します。\n<code>encoding</code> は <code>&#39;hex&#39;</code>、<code>&#39;binary&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `hmac` object can not be used after `digest()` method has been\ncalled.\n-->\n\n<p>注意: <code>digest()</code> メソッドが呼び出された後で <code>hmac</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<!--\nClass for encrypting data.\n-->\n\n<p>データを暗号化するためのクラスです。\n\n</p>\n<!--\nReturned by `crypto.createCipher` and `crypto.createCipheriv`.\n-->\n\n<p><code>crypto.createCipher</code> および <code>crypto.createCipheriv</code> から返されます。\n\n</p>\n<!--\nCipher objects are [streams](stream.html) that are both readable and\nwritable.  The written plain text data is used to produce the\nencrypted data on the readable side.  The legacy `update` and `final`\nmethods are also supported.\n-->\n\n<p>暗号化オブジェクトは読み込みと書き込みの両方が可能な\n<a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたプレーンテキストデータは、読み込み側に暗号化されたデータを\n生成するために使われます。\nレガシーな <code>update()</code> および <code>final()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "cipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the cipher with `data`, the encoding of which is given in\n`input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.  If no\nencoding is provided, then a buffer is expected.\nIf `data` is a `Buffer` then `input_encoding` is ignored.\n-->\n\n<p><code>data</code> で暗号を更新します。\n<code>input_encoding</code> で与えられるエンコーディングは <code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code>、<code>&#39;binary&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThe `output_encoding` specifies the output format of the enciphered\ndata, and can be `'binary'`, `'base64'` or `'hex'`.  If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p><code>output_encoding</code> は暗号化されたデータの出力フォーマットを指定するもので、\n<code>&#39;utf8&#39;</code>、<code>&#39;ascii&#39;</code> または <code>&#39;binary&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nReturns the enciphered contents, and can be called many times with new\ndata as it is streamed.\n-->\n\n<p>暗号化されたコンテンツが返されます。これは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining enciphered contents, with `output_encoding`\nbeing one of: `'binary'`, `'base64'` or `'hex'`.  If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p>暗号化されたコンテンツの残りを返します。\n<code>output_encoding</code> は次のいずれかです: <code>&#39;binary&#39;</code>、<code>&#39;base64&#39;</code> または <code>&#39;hex&#39;</code>。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `cipher` object can not be used after `final()` method has been\ncalled.\n-->\n\n<p>注意: <code>final()</code> メソッドが呼び出された後で <code>cipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable automatic padding of the input data to block size. If\n`auto_padding` is false, the length of the entire input data must be a\nmultiple of the cipher's block size or `final` will fail.  Useful for\nnon-standard padding, e.g. using `0x0` instead of PKCS padding. You\nmust call this before `cipher.final`.\n-->\n\n<p>入力データが自動的にブロックサイズにパディングされることを\n抑止することができます。\n<code>auto_padding</code> が <code>false</code> の場合、入力データ全体の長さは\n暗号ブロックサイズの倍数でなければなりません。\nでなければ、<code>final()</code> は失敗します。\nこれは非標準のパディング、たとえば PKCS パディングの代わりに\n<code>0x0</code> を使う場合に便利です。\n<code>cipher.final()</code> の前に呼び出す必要があります。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<!--\nClass for decrypting data.\n\nReturned by `crypto.createDecipher` and `crypto.createDecipheriv`.\n-->\n\n<p>復号化のためのクラスです。\n\n</p>\n<p><code>crypto.createDecipher</code> および <code>crypto.createDecipheriv</code> から返されます。\n\n</p>\n<!--\nDecipher objects are [streams](stream.html) that are both readable and\nwritable.  The written enciphered data is used to produce the\nplain-text data on the the readable side.  The legacy `update` and\n`final` methods are also supported.\n-->\n\n<p>復号化オブジェクトは読み込みと書き込みの両方が可能な\n<a href="\"stream.html\"">ストリーム</a> です。\n書き込まれた暗号化データは、読み込み側にプレーンテキストデータを\n生成するために使われます。\nレガシーな <code>update()</code> および <code>final()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the decipher with `data`, which is encoded in `'binary'`,\n`'base64'` or `'hex'`.  If no encoding is provided, then a buffer is\nexpected.\nIf `data` is a `Buffer` then `input_encoding` is ignored.\n-->\n\n<p><code>&#39;binary&#39;</code>、<code>&#39;base64&#39;</code> または <code>&#39;hex&#39;</code> のいずれかでエンコードされた復号を\n<code>data</code> で更新します。\nエンコーディングが与えられなかった場合はバッファが期待されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThe `output_decoding` specifies in what format to return the\ndeciphered plaintext: `'binary'`, `'ascii'` or `'utf8'`.  If no\nencoding is provided, then a buffer is returned.\n-->\n\n<p><code>output_decoding</code> は復号化されたプレーンテキストのフォーマットを指定するもので、\n<code>&#39;binary&#39;</code>、<code>&#39;ascii&#39;</code> あるいは <code>&#39;utf8&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining plaintext which is deciphered, with\n`output_encoding` being one of: `'binary'`, `'ascii'` or `'utf8'`.  If\nno encoding is provided, then a buffer is returned.\n-->\n\n<p>復号化されたプレーンテキストの残りを返します。\n<code>output_decoding</code> は <code>&#39;binary&#39;</code>、<code>&#39;ascii&#39;</code> あるいは <code>&#39;utf8&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `decipher` object can not be used after `final()` method has been\ncalled.\n-->\n\n<p>注意: <code>final()</code> メソッドが呼び出された後で <code>decipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable auto padding if the data has been encrypted without\nstandard block padding to prevent `decipher.final` from checking and\nremoving it. Can only work if the input data's length is a multiple of\nthe ciphers block size. You must call this before streaming data to\n`decipher.update`.\n-->\n\n<p>データブロックが非標準のパディングで暗号化されている場合、\n<code>decipher.final()</code> によるチェックを無効にすることができます。\n入力データの長さが暗号ブロックサイズの倍数の場合のみ動作します。\n<code>decipher.update()</code> の前に呼び出す必要があります。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Sign",
          "type": "class",
          "name": "Sign",
          "desc": "<!--\nClass for generating signatures.\n\nReturned by `crypto.createSign`.\n-->\n\n<p>署名を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createSign</code> から返されます。\n\n</p>\n<!--\nSign objects are writable [streams](stream.html).  The written data is\nused to generate the signature.  Once all of the data has been\nwritten, the `sign` method will return the signature.  The legacy\n`update` method is also supported.\n-->\n\n<p>署名オブジェクトは書き込み可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータは署名を生成するために使われます。\n全てのデータが書き込まれると、<code>sign()</code> メソッドはその署名を返します。\nレガシーな <code>update()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "sign.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the sign object with data.  This can be called many times\nwith new data as it is streamed.\n-->\n\n<p>署名オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sign.sign(private_key, [output_format])",
              "type": "method",
              "name": "sign",
              "desc": "<!--\nCalculates the signature on all the updated data passed through the\nsign.  `private_key` is a string containing the PEM encoded private\nkey for signing.\n-->\n\n<p>署名オブジェクトに渡された全ての更新データで署名を計算します。\n<code>private_key</code> は PEM でエンコードされた秘密鍵を内容とする文字列です。\n\n</p>\n<!--\nReturns the signature in `output_format` which can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nreturned.\n-->\n\n<p><code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、あるいは <code>&#39;base64&#39;</code> のいずれかを指定した <code>output_format</code>\nによる署名を返します。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `sign` object can not be used after `sign()` method has been\ncalled.\n-->\n\n<p>注意: <code>sign()</code> メソッドが呼び出された後で <code>sign</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<!--\nClass for verifying signatures.\n\nReturned by `crypto.createVerify`.\n-->\n\n<p>署名を検証するためのクラスです。\n\n</p>\n<p><code>crypto.createVerify</code> から返されます。\n\n</p>\n<!--\nVerify objects are writable [streams](stream.html).  The written data\nis used to validate against the supplied signature.  Once all of the\ndata has been written, the `verify` method will return true if the\nsupplied signature is valid.  The legacy `update` method is also\nsupported.\n-->\n\n<p>検証オブジェクトは書き込み可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータは与えられた署名を検証するために使われます。\n全てのデータが書き込まれると、<code>verify()</code> メソッドは与えられた署名が正しければ\n<code>true</code> を返します。\nレガシーな <code>update()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the verifier object with data.  This can be called many times\nwith new data as it is streamed.\n-->\n\n<p>検証オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature, [signature_format])",
              "type": "method",
              "name": "verify",
              "desc": "<!--\nVerifies the signed data by using the `object` and `signature`.\n`object` is  a string containing a PEM encoded object, which can be\none of RSA public key, DSA public key, or X.509 certificate.\n`signature` is the previously calculated signature for the data, in\nthe `signature_format` which can be `'binary'`, `'hex'` or `'base64'`.\nIf no encoding is specified, then a buffer is expected.\n-->\n\n<p>署名されたデータを <code>object</code> と <code>signature</code> で検証します。\n<code>object</code> は RSA 公開鍵、DSA 公開鍵、X.509証明書のいずれかを\nPEM でエンコードしたオブジェクトです。\n<code>signature</code> は先に計算したデータの署名で、\nその <code>signature_format</code> は <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code>\nのいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n<!--\nReturns true or false depending on the validity of the signature for\nthe data and public key.\n-->\n\n<p>署名されたデータと公開鍵による検証の結果によって true または false を返します。\n\n</p>\n<!--\nNote: `verifier` object can not be used after `verify()` method has been\ncalled.\n-->\n\n<p>注意: <code>verify()</code> メソッドを呼び出した後で <code>verifier</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<!--\nThe class for creating Diffie-Hellman key exchanges.\n\nReturned by `crypto.createDiffieHellman`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有のためのクラスです。\n\n</p>\n<p><code>crypto.creaateDiffieHellman</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<!--\nGenerates private and public Diffie-Hellman key values, and returns\nthe public key in the specified encoding. This key should be\ntransferred to the other party. Encoding can be `'binary'`, `'hex'`,\nor `'base64'`.  If no encoding is provided, then a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法で秘密および公開鍵を作成し、\n指定の方法でエンコーディングされた公開鍵を返します。\nこの鍵は相手側に渡されるものです。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<!--\nComputes the shared secret using `other_public_key` as the other\nparty's public key and returns the computed shared secret. Supplied\nkey is interpreted using specified `input_encoding`, and secret is\nencoded using specified `output_encoding`. Encodings can be\n`'binary'`, `'hex'`, or `'base64'`. If the input encoding is not\nprovided, then a buffer is expected.\n-->\n\n<p><code>other_public_key</code> を相手側の公開鍵として共有の秘密鍵を計算して返します。\n与えられた公開鍵は指定の <code>input_encoding</code> を使って解釈され、\n秘密鍵は <code>output_encoding</code> で指定された方法でエンコードされます。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\n入力のエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n<!--\nIf no output encoding is given, then a buffer is returned.\n-->\n\n<p>出力のエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<!--\nReturns the Diffie-Hellman prime in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法の素数を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<!--\nReturns the Diffie-Hellman generator in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法の生成元を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<!--\nReturns the Diffie-Hellman public key in the specified encoding, which\ncan be `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<!--\nReturns the Diffie-Hellman private key in the specified encoding,\nwhich can be `'binary'`, `'hex'`, or `'base64'`. If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を指定のエンコーディングで返します。\nエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key, [encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<!--\nSets the Diffie-Hellman public key. Key encoding can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nexpected.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を設定します。\n鍵のエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(private_key, [encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<!--\nSets the Diffie-Hellman private key. Key encoding can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nexpected.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を設定します。\n鍵のエンコーディングは <code>&#39;binary&#39;</code>、<code>&#39;hex&#39;</code>、または <code>&#39;base64&#39;</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "crypto.DEFAULT_ENCODING",
          "name": "DEFAULT_ENCODING",
          "desc": "<!--\nThe default encoding to use for functions that can take either strings\nor buffers.  The default value is `'buffer'`, which makes it default\nto using Buffer objects.  This is here to make the crypto module more\neasily compatible with legacy programs that expected `'binary'` to be\nthe default encoding.\n-->\n\n<p>関数が使用するエンコーディングのデフォルトは、文字列かバッファの\nいずれかにすることができます。\n\n</p>\n<!--\nNote that new programs will probably expect buffers, so only use this\nas a temporary measure.\n-->\n\n<p>新しいプログラムはおそらくバッファを期待することに注意してください。\nこれは一時的な手段としてのみ使用してください。\n\n</p>\n"
        }
      ],
      "modules": [
        {
          "textRaw": "Recent API Changes",
          "name": "recent_api_changes",
          "desc": "<!--\nThe Crypto module was added to Node before there was the concept of a\nunified Stream API, and before there were Buffer objects for handling\nbinary data.\n-->\n\n<p>Crypto モジュールは、統合されたストリーム API やバイトデータを扱う Buffer\nオブジェクトよりも先に Node に追加されました。\n\n</p>\n<!--\nAs such, the streaming classes don't have the typical methods found on\nother Node classes, and many methods accepted and returned\nBinary-encoded strings by default rather than Buffers.  This was\nchanged to use Buffers by default instead.\n-->\n\n<p>そのため、このストリーミングなクラスは他の Node のクラスに見られる\n典型的なメソッドを持たず、多くのメソッドは引数や戻り値に\nBuffer ではなくバイナリエンコードされた文字列を使います。\n\n</p>\n<!--\nThis is a breaking change for some use cases, but not all.\n-->\n\n<p>これはあるユースケースにおいては互換性を損ないますが、\n全てのケースではありません。\n\n</p>\n<!--\nFor example, if you currently use the default arguments to the Sign\nclass, and then pass the results to the Verify class, without ever\ninspecting the data, then it will continue to work as before.  Where\nyou once got a binary string and then presented the binary string to\nthe Verify object, you'll now get a Buffer, and present the Buffer to\nthe Verify object.\n-->\n\n<p>たとえば、Sign クラスをデフォルト引数で使っていて、\nその結果を全く調べずに Verify クラスに渡している場合、\nそれは以前と同じように動くでしょう。\nそれは、現時点ではバイナリ文字列を受け取ってそのバイナリ文字列を\nVeriy オブジェクトに渡しますが、将来は Buffer を受け取ってその\nBuffer を Verify オブジェクトに渡すようになります。\n\n</p>\n<!--\nHowever, if you were doing things with the string data that will not\nwork properly on Buffers (such as, concatenating them, storing in\ndatabases, etc.), or you are passing binary strings to the crypto\nfunctions without an encoding argument, then you will need to start\nproviding encoding arguments to specify which encoding you'd like to\nuse.  To switch to the previous style of using binary strings by\ndefault, set the `crypto.DEFAULT_ENCODING` field to 'binary'.  Note\nthat new programs will probably expect buffers, so only use this as a\ntemporary measure.\n-->\n\n<p>しかしながら、Buffer が文字列と正確に同じようには動かない何かをしている場合\n(例えば、それらを連結したり、データベースに保存したりするなど)、\nあるいはバイナリ文字列を Crypto の関数にエンコーディング引数無しで\n渡している場合、エンコーディング引数を与えてどのエンコーディングを\n使用しているかを指定する必要があります。\n以前のようにデフォルトでバイナリ文字列を使うように切り替えるには、\n<code>crypto.DEFAULT_ENCODING</code> フィールドに <code>binary</code> を設定します。\n新しいプログラムはおそらくバッファを期待することに注意してください。\nこれは一時的な手段としてのみ使用してください。\n\n\n</p>\n",
          "type": "module",
          "displayName": "Recent API Changes"
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    }
  ]
}
