{
  "source": "doc/api/stream.markdown",
  "modules": [
    {
      "textRaw": "Stream",
      "name": "stream",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\nA stream is an abstract interface implemented by various objects in\nNode.  For example a [request to an HTTP\nserver](http.html#http_http_incomingmessage) is a stream, as is\n[stdout][]. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n-->\n\n<p>ストリームは Node の様々なオブジェクトで実装される抽象的なインタフェースです。\n例えば <a href="\"http.html#http_http_incomingmessage\"">HTTP サーバへのリクエスト</a>は\n[標準出力][]と同様にストリームです。\nストリームは読み込み可能、書き込み可能、またはその両方です。\n全てのストリームは [EventEmitter][] のインスタンスです。\n\n</p>\n<!--\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for [Readable][] streams, [Writable][]\nstreams, [Duplex][] streams, and [Transform][] streams.\n-->\n\n<p>Stream のベースクラスは <code>require(&#39;stream&#39;)</code> でロードすることができます。\n[Readable][] ストリーム、[Writable][] ストリーム、[Duplex][] ストリーム、\n[Transform][] ストリームのベースクラスが提供されます。\n\n</p>\n<!--\nThis document is split up into 3 sections.  The first explains the\nparts of the API that you need to be aware of to use streams in your\nprograms.  If you never implement a streaming API yourself, you can\nstop there.\n-->\n\n<p>このドキュメントは 3 つのセクションに分かれています。\n最初に、プログラムでストリームを利用するために知っておく必要がある\nAPI について説明します。\nもし独自のストリーミング API を実装しないのであれば、\nそこで終わりにすることができます。\n\n</p>\n<!--\nThe second section explains the parts of the API that you need to use\nif you implement your own custom streams yourself.  The API is\ndesigned to make this easy for you to do.\n-->\n\n<p>2番目のセクションでは、独自のストリームを実装する場合に必要となる\nAPI について説明します。\nこの API はそれが簡単にできるように設計されています。\n\n</p>\n<!--\nThe third section goes into more depth about how streams work,\nincluding some of the internal mechanisms and functions that you\nshould probably not modify unless you definitely know what you are\ndoing.\n-->\n\n<p>3番目のセクションは、理解することなく変更してはならない\n内部的なメカニズムや関数群を含めて、ストリームがどのように動作するかについて\nより詳しく説明します。\n\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: stream.Readable",
          "type": "class",
          "name": "stream.Readable",
          "desc": "<!--\nThe Readable stream interface is the abstraction for a *source* of\ndata that you are reading from.  In other words, data comes *out* of a\nReadable stream.\n-->\n\n<p>Readable ストリームのインターフェースは、あなたが読み込むデータの抽象的な\n<em>発生源</em> です。言い換えると、データは Readable ストリームから <em>出て</em> きます。\n\n</p>\n<!--\nA Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.\n-->\n\n<p>Readable ストリームは、あなたがデータを受け取る準備ができたと指示するまでは、\nデータの生成を開始しません。\n\n</p>\n<!--\nReadable streams have two \"modes\": a **flowing mode** and a **non-flowing\nmode**.  When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible.  In non-flowing\nmode, you must explicitly call `stream.read()` to get chunks of data\nout.\n-->\n\n<p>Readable ストリームは二つの &quot;モード&quot;: <strong>flowing モード</strong> と\n<strong>non-flowing モード</strong> を持っています。\nflowing モードに入ると、データは下層のシステムから読み込まれると、\n可能な限り素早くあなたのプログラムに届けられます。\nnon-flowing モードでは、データの断片を取り出すために、明示的に\n<code>stream.read()</code> を呼び出す必要があります。\n\n</p>\n<!--\nExamples of readable streams include:\n-->\n\n<p>Readable ストリームを含む例:\n\n</p>\n<!--\n* [http responses, on the client](http.html#http_http_incomingmessage)\n* [http requests, on the server](http.html#http_http_incomingmessage)\n* [fs read streams](fs.html#fs_class_fs_readstream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdout and stderr][]\n* [process.stdin][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_http_incomingmessage\"">クライアントの http レスポンス</a></li>\n<li><a href="\"http.html#http_http_incomingmessage\"">サーバの http リクエスト</a></li>\n<li><a href="\"fs.html#fs_class_fs_readstream\"">fs の ReadStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li>[child_process の標準出力と標準エラー出力][]</li>\n<li>[process.stdin][]</li>\n</ul>\n",
          "events": [
            {
              "textRaw": "Event: 'readable'",
              "type": "event",
              "name": "readable",
              "desc": "<!--\nWhen a chunk of data can be read from the stream, it will emit a\n`'readable'` event.\n-->\n\n<p>ストリームからデータの断片を読み込むことが可能となった時、\n<code>&#39;readable&#39;</code> イベントが生成されます。\n\n</p>\n<!--\nIn some cases, listening for a `'readable'` event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn't already.\n-->\n\n<p>あるケースでは、<code>&#39;readable&#39;</code> イベントを監視することは下層のシステムからデータを内部バッファへ読み込む原因となります (それがまだ行われていなかった場合)。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, function() {\n  // there is some data to read now\n})</code></pre>\n<!--\nOnce the internal buffer is drained, a `readable` event will fire\nagain when more data is available.\n-->\n\n<p>内部バッファが空になると、データが利用可能になった時に\n<code>&#39;readable&#39;</code> イベントは再び生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<!--\n* `chunk` {Buffer | String} The chunk of data.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} データの断片。</li>\n</ul>\n<!--\nIf you attach a `data` event listener, then it will switch the stream\ninto flowing mode, and data will be passed to your handler as soon as\nit is available.\n-->\n\n<p><code>&#39;data&#39;</code> イベントのリスナを追加すると、ストリームは flowing モードに切り替わり、\nデータは利用可能になるとすぐにあなたのハンドラに渡されます。\n\n</p>\n<!--\nIf you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.\n-->\n\n<p>ストリームから出てくる全てのデータをできるだけ素早く欲しいのなら、\nこれが最善の方法です。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n})</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<!--\nThis event fires when no more data will be provided.\n-->\n\n<p>このイベントは、提供するデータがもう無くなった場合に生成されます。\n\n</p>\n<!--\nNote that the `end` event **will not fire** unless the data is\ncompletely consumed.  This can be done by switching into flowing mode,\nor by calling `read()` repeatedly until you get to the end.\n-->\n\n<p><code>&#39;end&#39;</code> イベントはデータが完全に消費されるまでは <strong>生成されない</strong>\nことに注意してください。\nそれは flowing モードに切り替えることによって、または終わりに達するまで\n<code>read()</code> を繰り返し呼び出すことによって達成することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n})\nreadable.on(&#39;end&#39;, function() {\n  console.log(&#39;there will be no more data.&#39;);\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n-->\n\n<p>下層のリソース (例えば背後のファイル記述子) がクローズされた時に生成されます。\n全てのストリームがこのイベントを発生するわけではありません。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\nEmitted if there was an error receiving data.\n-->\n\n<p>データの受信でエラーがあると生成されます。\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "readable.read([size])",
              "type": "method",
              "name": "read",
              "desc": "<!--\n* `size` {Number} Optional argument to specify how much data to read.\n* Return {String | Buffer | null}\n-->\n\n<ul>\n<li><code>size</code> {Number} どれだけのデータを読み込むか指定するオプションの引数。</li>\n<li>Return {String | Buffer | null}</li>\n</ul>\n<!--\nThe `read()` method pulls some data out of the internal buffer and\nreturns it.  If there is no data available, then it will return\n`null`.\n-->\n\n<p><code>read()</code> メソッドは内部バッファからデータを取り出して返します。\nもし利用可能なデータが無ければ、<code>null</code> を返します。\n\n</p>\n<!--\nIf you pass in a `size` argument, then it will return that many\nbytes.  If `size` bytes are not available, then it will return `null`.\n-->\n\n<p><code>size</code> 引数を指定すると、その長さ (バイト数または文字数) のデータを返します。\nもし <code>size</code> で指定された長さのデータが揃っていない場合は <code>null</code> を返します。\n\n</p>\n<!--\nIf you do not specify a `size` argument, then it will return all the\ndata in the internal buffer.\n-->\n\n<p><code>size</code> 引数を指定しなかった場合は、内部バッファにある全てのデータが返されます。\n\n</p>\n<!--\nThis method should only be called in non-flowing mode.  In\nflowing-mode, this method is called automatically until the internal\nbuffer is drained.\n-->\n\n<p>このメソッドは non-flowing モードの場合に限って呼び出されるべきです。\nflowing モードでは、内部バッファが空になるまで\nこのメソッドは自動的に呼び出されます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, function() {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  }\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.setEncoding(encoding)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<!--\n* `encoding` {String} The encoding to use.\n-->\n\n<ul>\n<li><code>encoding</code> {String} 使用するエンコーディング。</li>\n</ul>\n<!--\nCall this function to cause the stream to return strings of the\nspecified encoding instead of Buffer objects.  For example, if you do\n`readable.setEncoding('utf8')`, then the output data will be\ninterpreted as UTF-8 data, and returned as strings.  If you do\n`readable.setEncoding('hex')`, then the data will be encoded in\nhexadecimal string format.\n-->\n\n<p>この関数を呼び出すと、ストリームは Buffer オブジェクトの代わりに\n指定されたエンコーディングによる文字列を返すようになります。\n例えば、<code>readable.setEncoding(&#39;utf8&#39;)</code> とすると、得られるデータは\nUTF-8 のデータとして解釈され、文字列が返されます。\n<code>readable.setEncoding(&#39;hex&#39;)</code> とすると、データは 16 進フォーマットの\n文字列にエンコードされます。\n\n</p>\n<!--\nThis properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled `buf.toString(encoding)` on them.  If you want to read the data\nas strings, always use this method.\n-->\n\n<p>これは、Buffer を直接取得して単純に <code>buf.toString(encoding)</code>\nを呼び出した場合は潜在的にめちゃくちゃになるのとは異なり、\nマルチバイト文字を正しく扱います。\nデータを文字列として読み込みたければ、常にこのメソッドを使用してください。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.setEncoding(&#39;utf8&#39;);\nreadable.on(&#39;data&#39;, function(chunk) {\n  assert.equal(typeof chunk, &#39;string&#39;);\n  console.log(&#39;got %d characters of string data&#39;, chunk.length);\n})</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<!--\nThis method will cause the readable stream to resume emitting `data`\nevents.\n-->\n\n<p>このメソッドは Readable ストリームが <code>&#39;data&#39;</code> イベントの生成を\n再開するようにします。\n\n</p>\n<!--\nThis method will switch the stream into flowing-mode.  If you do *not*\nwant to consume the data from a stream, but you *do* want to get to\nits `end` event, you can call `readable.resume()` to open the flow of\ndata.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えます。\nもしストリームからのデータを消費する必要が <em>なく</em>、しかし <code>&#39;end&#39;</code> イベントを\n受け取る必要が <em>ある</em> なら、<code>readable.resume()</code> を呼び出してデータのフローを\n開くことができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on(&#39;end&#39;, function(chunk) {\n  console.log(&#39;got to the end, but did not read anything&#39;);\n})</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "readable.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<!--\nThis method will cause a stream in flowing-mode to stop emitting\n`data` events.  Any data that becomes available will remain in the\ninternal buffer.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えて、\n<code>&#39;data&#39;</code> イベントの生成を中断します。\n利用可能になったデータは内部バッファの中に残ります。\n\n</p>\n<!--\nThis method is only relevant in flowing mode.  When called on a\nnon-flowing stream, it will switch into flowing mode, but remain\npaused.\n-->\n\n<p>このメソッドは flowing モードにだけ関連します。\nnon-flowing モードのストリームで呼ばれた場合は、flowing モードに切り替わり、\n残りのデータは休止します。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  readable.pause();\n  console.log(&#39;there will be no more data for 1 second&#39;);\n  setTimeout(function() {\n    console.log(&#39;now data will start flowing again&#39;);\n    readable.resume();\n  }, 1000);\n})</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "readable.pipe(destination, [options])",
              "type": "method",
              "name": "pipe",
              "* `destination` {[Writable][] Stream} The destination for writing data\n* `options` {Object} Pipe options\n  * `end` {Boolean} End the writer when the reader ends. Default": "`true`",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {[Writable][] Stream} データの書き込み先。 ",
                      "name": "destination",
                      "type": "[Writable][] Stream",
                      "desc": "データの書き込み先。"
                    },
                    {
                      "textRaw": "`options` {Object} パイプオプション ",
                      "options": [
                        {
                          "textRaw": "`end` {Boolean} 読み込み元が終了すると書き込み先を終了します。 デフォルトは `true` ",
                          "name": "end",
                          "type": "Boolean",
                          "desc": "読み込み元が終了すると書き込み先を終了します。 デフォルトは `true`"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "パイプオプション",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nThis method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.\n-->\n\n<p>このメソッドは Readable ストリームから全てのデータを引き出し、\n与えられた行き先に書き込みます。\n高速な Readable ストリームによって出力先が圧迫されないように、\n自動的にフロー制御を行います。\n\n</p>\n<!--\nMultiple destinations can be piped to safely.\n-->\n\n<p>複数の出力先を安全に連結することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;\nreadable.pipe(writable);</code></pre>\n<!--\nThis function returns the destination stream, so you can set up pipe\nchains like so:\n-->\n\n<p>この関数は出力先となるストリーム返すので、このようにパイプのチェーンを\n組み立てることができます。\n\n</p>\n<pre><code class="\"javascript\"">var r = fs.createReadStream(&#39;file.txt&#39;);\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream(&#39;file.txt.gz&#39;);\nr.pipe(z).pipe(w);</code></pre>\n<!--\nFor example, emulating the Unix `cat` command:\n-->\n\n<p>Unix の <code>cat</code> コマンドをエミュレートする例:\n\n</p>\n<pre><code class="\"javascript\"">process.stdin.pipe(process.stdout);</code></pre>\n<!--\nBy default [`end()`][] is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n-->\n\n<p>デフォルトでは、出力先の [<code>end()</code>][] は入力元のストリームで\n<code>&#39;end&#39;</code> が生成された時に呼び出されます。そのため、<code>destination</code>\nはもう書き込み可能ではなくなります。\n<code>{end: false }</code> を <code>options</code> として渡すことにより、出力先ストリームを\nオープンしたままにしておくことができます。\n\n</p>\n<!--\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n-->\n\n<p>これは <code>writer</code> をオープンしたままにすることにより、最後に\n<code>&quot;Goodbye&quot;</code> と書き込むことができます。\n\n</p>\n<pre><code class="\"javascript\"">reader.pipe(writer, { end: false });\nreader.on(&#39;end&#39;, function() {\n  writer.end(&#39;Goodbye\\n&#39;);\n});</code></pre>\n<!--\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n-->\n\n<p><code>process.stderr</code> および <code>process.stdout</code> は、オプションの指定に関係なく、\nプロセスが終了するまで決してクローズされないことに注意してください。\n\n</p>\n"
            },
            {
              "textRaw": "readable.unpipe([destination])",
              "type": "method",
              "name": "unpipe",
              "desc": "<!--\n* `destination` {[Writable][] Stream} Optional specific stream to unpipe\n-->\n\n<ul>\n<li><code>destination</code> {[Writable][] Stream} オプションのパイプを解除するストリーム</li>\n</ul>\n<!--\nThis method will remove the hooks set up for a previous `pipe()` call.\n-->\n\n<p>このメソッドは以前の <code>pipe()</code> 呼び出しで設定されたフックを取り除きます。\n\n</p>\n<!--\nIf the destination is not specified, then all pipes are removed.\n-->\n\n<p><code>destination</code> が指定されなかった場合は、全てのパイプが取り除かれます。\n\n</p>\n<!--\nIf the destination is specified, but no pipe is set up for it, then\nthis is a no-op.\n-->\n\n<p><code>destination</code> が指定されたものの、それがパイプされていなかった場合、\nこれは何もしません。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;,\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(function() {\n  console.log(&#39;stop writing to file.txt&#39;);\n  readable.unpipe(writable);\n  console.log(&#39;manually close the file stream&#39;);\n  writable.end();\n}, 1000);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "destination",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.unshift(chunk)",
              "type": "method",
              "name": "unshift",
              "desc": "<!--\n* `chunk` {Buffer | String} Chunk of data to unshift onto the read queue\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} 読み込みキューの先頭に戻されるデータの断片</li>\n</ul>\n<!--\nThis is useful in certain cases where a stream is being consumed by a\nparser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.\n-->\n\n<p>これはストリームがパーサによって消費されるケースにおいて有用です。\nそれはソースから楽観的に取り出したデータを「消費しなかった」ことにして、\nストリームが他のところにデータを渡せるようにする場合に必要です。\n\n</p>\n<!--\nIf you find that you must often call `stream.unshift(chunk)` in your\nprograms, consider implementing a [Transform][] stream instead.  (See API\nfor Stream Implementors, below.)\n-->\n\n<p><code>stream.unshift(chunk)</code> を頻繁に呼び出さなくてはならないとしたら、\n代わりに [Transform][] ストリームを実装することを検討してください\n(後述する [ストリーム実装者向けの API][] を参照してください)。\n\n</p>\n<pre><code class="\"javascript\"">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nvar StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on(&#39;error&#39;, callback);\n  stream.on(&#39;readable&#39;, onReadable);\n  var decoder = new StringDecoder(&#39;utf8&#39;);\n  var header = &#39;&#39;;\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join(&#39;\\n\\n&#39;);\n        var buf = new Buffer(remaining, &#39;utf8&#39;);\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener(&#39;error&#39;, callback);\n        stream.removeListener(&#39;readable&#39;, onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.wrap(stream)",
              "type": "method",
              "name": "wrap",
              "desc": "<!--\n* `stream` {Stream} An \"old style\" readable stream\n-->\n\n<ul>\n<li><code>stream</code> {Stream} 「古いスタイル」の Readable ストリーム</li>\n</ul>\n<!--\nVersions of Node prior to v0.10 had streams that did not implement the\nentire Streams API as it is today.  (See \"Compatibility\" below for\nmore information.)\n-->\n\n<p>v0.10 より前のバージョンの Node には、今日の全ストリーム API を実装していない\nストリームがありました (より詳細は後述する「[互換性][]」を参照してください)。\n\n</p>\n<!--\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a [Readable][] stream that uses the old stream\nas its data source.\n-->\n\n<p>もし、<code>&#39;data&#39;</code> イベントを生成し、アドバイスだけを行う <code>pause()</code>\nメソッドを持つ、古い Node ライブラリを使っているなら、\n<code>wrap()</code> メソッドは古いストリームをデータソースとして使用する\n[Readable][] ストリームを作成します。\n\n</p>\n<!--\nYou will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node programs and libraries.\n-->\n\n<p>この関数を呼び出す必要は滅多にありませんが、これは古い Node\nプログラム及びライブラリと相互作用するための利便性のために存在します。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code class="\"javascript\"">var OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nvar oreader = new OldReader;\nvar Readable = require(&#39;stream&#39;).Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, function() {\n  myReader.read(); // etc.\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "stream"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: stream.Writable",
          "type": "class",
          "name": "stream.Writable",
          "desc": "<!--\nThe Writable stream interface is an abstraction for a *destination*\nthat you are writing data *to*.\n-->\n\n<p>Writable ストリームのインターフェースは、あなたがデータを書き込む抽象的な\n<em>行き先</em> です。\n\n</p>\n<!--\nExamples of writable streams include:\n-->\n\n<p>Writable ストリームを含む例:\n\n</p>\n<!--\n* [http requests, on the client](http.html#http_class_http_clientrequest)\n* [http responses, on the server](http.html#http_class_http_serverresponse)\n* [fs write streams](fs.html#fs_class_fs_writestream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdin](child_process.html#child_process_child_stdin)\n* [process.stdout][], [process.stderr][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_class_http_clientrequest\"">クライアントの http リクエスト</a></li>\n<li><a href="\"http.html#http_class_http_serverresponse\"">サーバの http レスポンス</a></li>\n<li><a href="\"fs.html#fs_class_fs_writestream\"">fs の WriteStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li><a href="\"child_process.html#child_process_child_stdin\"">child_process の標準入力</a></li>\n<li>[process.stdout][], [process.stderr][]</li>\n</ul>\n",
          "methods": [
            {
              "textRaw": "writable.write(chunk, [encoding], [callback])",
              "type": "method",
              "name": "write",
              "desc": "<!--\n* `chunk` {String | Buffer} The data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Callback for when this chunk of data is flushed\n* Returns: {Boolean} True if the data was handled completely.\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} 書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} データが掃き出された時に呼び出されるコールバック</li>\n<li>Returns: {Boolean} データが完全に処理された場合は <code>true</code>。</li>\n</ul>\n<!--\nThis method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.\n-->\n\n<p>このメソッドはデータを下層のシステムに書き込み、データが完全に処理されると\n与えられたコールバックを一度だけ呼び出します。\n\n</p>\n<!--\nThe return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n`false`.  Otherwise, it will return `true`.\n-->\n\n<p>戻り値は書き込みをすぐに続けていいかどうかを示します。\nもしデータが内部にバッファリングされなければならないなら <code>false</code> を返します。\nそうでなければ <code>true</code> を返します。\n\n</p>\n<!--\nThis return value is strictly advisory.  You MAY continue to write,\neven if it returns `false`.  However, writes will be buffered in\nmemory, so it is best not to do this excessively.  Instead, wait for\nthe `drain` event before writing more data.\n-->\n\n<p>この戻り値は完全にアドバイス的です。\nもしこれが <code>false</code> を返しても、あなたは書き込みを続けることが「できます」。\nしかしながら、書き込まれたデータはメモリにバッファリングされるため、\nこれを過剰にしないことが最善です。\n代わりに、より多くのデータを書く前に <code>&#39;drain&#39;</code> イベントを待機してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "writable.end([chunk], [encoding], [callback])",
              "type": "method",
              "name": "end",
              "desc": "<!--\n* `chunk` {String | Buffer} Optional data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Optional callback for when the stream is finished\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} オプションの書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} ストリームが終了時に呼び出される、\nオプションのコールバック</li>\n</ul>\n<!--\nCall this method when no more data will be written to the stream.  If\nsupplied, the callback is attached as a listener on the `finish` event.\n-->\n\n<p>これ以上データをストリームに書き込まない場合に呼び出してください。\nコールバックが与えられた場合、それは <code>&#39;finish&#39;</code> イベントのリスナとして\nアタッチされます。\n\n</p>\n<!--\nCalling [`write()`][] after calling [`end()`][] will raise an error.\n-->\n\n<p>[<code>end()</code>][] を呼び出した後で [<code>write()</code>][] を呼び出すとエラーになります。\n\n</p>\n<pre><code class="\"javascript\"">// write &#39;hello, &#39; and then end with &#39;world!&#39;\nhttp.createServer(function (req, res) {\n  res.write(&#39;hello, &#39;);\n  res.end(&#39;world!&#39;);\n  // writing more now is not allowed!\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<!--\nIf a [`writable.write(chunk)`][] call returns false, then the `drain`\nevent will indicate when it is appropriate to begin writing more data\nto the stream.\n-->\n\n<p>[<code>write(chunk, encoding, callback)</code>][] の呼び出しが <code>false</code> を返した場合、\nより多くのデータをいつストリームに書き始めるのが適切かを\n<code>&#39;drain&#39;</code> イベントによって示します。\n\n</p>\n<pre><code class="\"javascript\"">// Write the data to the supplied writable stream 1MM times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don&#39;t pass the callback, because we&#39;re not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once(&#39;drain&#39;, write);\n    }\n  }\n}</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "desc": "<!--\nWhen the [`end()`][] method has been called, and all data has been flushed\nto the underlying system, this event is emitted.\n-->\n\n<p>[<code>end()</code>][] メソッドが呼び出されて、全てのデータが下層のシステムに\n掃き出されると、このイベントが生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write(&#39;hello, #&#39; + i + &#39;!\\n&#39;);\n}\nwriter.end(&#39;this is the end\\n&#39;);\nwriter.on(&#39;finish&#39;, function() {\n  console.error(&#39;all writes are now complete.&#39;);\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pipe'",
              "type": "event",
              "name": "pipe",
              "desc": "<!--\n* `src` {[Readable][] Stream} source stream that is piping to this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームにつながれた\n入力元のストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the `pipe()` method is called on a readable\nstream, adding this writable to its set of destinations.\n-->\n\n<p>これは、Readable ストリームの <code>pipe()</code> メソッドが呼び出されて、\nこの Writable ストリームが出力先として加えられた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;pipe&#39;, function(src) {\n  console.error(&#39;something is piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'unpipe'",
              "type": "event",
              "name": "unpipe",
              "desc": "<!--\n* `src` {[Readable][] Stream} The source stream that [unpiped][] this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームと[切り離された][]\n入力元の Readable ストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the [`unpipe()`][] method is called on a\nreadable stream, removing this writable from its set of destinations.\n-->\n\n<p>これは、Readable ストリームで [<code>unpipe()</code>][] メソッドが呼び出され、\nこの Writable ストリームが出力先から取り除かれた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;unpipe&#39;, function(src) {\n  console.error(&#39;something has stopped piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\nEmitted if there was an error when writing or piping data.\n-->\n\n<p>データの書き込み中またはパイプ中にエラーが発生した場合に生成されます。\n\n</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: stream.Duplex",
          "type": "class",
          "name": "stream.Duplex",
          "desc": "<!--\nDuplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Duplex ストリームは [Readable][] と [Writable][] 両方のインターフェースを\n実装したストリームです。使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Duplex streams include:\n-->\n\n<p>Duplex ストリームを含む例:\n\n</p>\n<!--\n* [tcp sockets][]\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[tcp のソケット][]</li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
        },
        {
          "textRaw": "Class: stream.Transform",
          "type": "class",
          "name": "stream.Transform",
          "desc": "<!--\nTransform streams are [Duplex][] streams where the output is in some way\ncomputed from the input.  They implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Transform ストリームは、入力から何らかの方法で出力が計算される [Duplex][]\nストリームです。\nそれらは [Readable][] と [Writable][] 両方のインターフェースを実装します。\n使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Transform streams include:\n-->\n\n<p>Transform ストリームを含む例:\n\n</p>\n<!--\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
        }
      ],
      "miscs": [
        {
          "textRaw": "API for Stream Consumers",
          "name": "API for Stream Consumers",
          "type": "misc",
          "desc": "<!--\nStreams can be either [Readable][], [Writable][], or both ([Duplex][]).\n-->\n\n<p>ストリームは、[Readable][]、[Writable][]、またはその両方 ([Duplex][])\nのいずれかになることができます。\n\n</p>\n<!--\nAll streams are EventEmitters, but they also have other custom methods\nand properties depending on whether they are Readable, Writable, or\nDuplex.\n-->\n\n<p>全てのストリームは EventEmitter ですが、Readable、Writable、または Duplex\nのいずれであるかによって、独自のメソッドやプロパティを持ちます。\n\n</p>\n<!--\nIf a stream is both Readable and Writable, then it implements all of\nthe methods and events below.  So, a [Duplex][] or [Transform][] stream is\nfully described by this API, though their implementation may be\nsomewhat different.\n-->\n\n<p>もしストリームが [Readable][] と[Writable][] の両方であるなら、\nそれは以下の全てのメソッドとイベントを実装します。\n[Duplex][] または [Transform][] ストリームの実装は多少異なる場合がありますが、\nこの API によって詳細に説明されます。\n\n</p>\n<!--\nIt is not necessary to implement Stream interfaces in order to consume\nstreams in your programs.  If you **are** implementing streaming\ninterfaces in your own program, please also refer to\n[API for Stream Implementors][] below.\n-->\n\n<p>プログラムの中でストリームからのデータを消費するために、\nストリームのインターフェースを実装する必要はありません。\nもしプログラムの中でストリーミングインターフェースを実装 <strong>する</strong> なら、\n以下の [ストリーム実装者向けの API][] を参照してください。\n\n</p>\n<!--\nAlmost all Node programs, no matter how simple, use Streams in some\nway.  Here is an example of using Streams in a Node program:\n-->\n\n<p>ほとんど全ての Node プログラムは、どんなに単純であっても、\n何らかの方法でストリームを利用します。\nこれはストリームを利用する Node プログラムの例です:\n\n</p>\n<pre><code class="\"javascript\"">var http = require(&#39;http&#39;);\n\nvar server = http.createServer(function (req, res) {\n  // req is an http.IncomingMessage, which is a Readable Stream\n  // res is an http.ServerResponse, which is a Writable Stream\n\n  var body = &#39;&#39;;\n  // we want to get the data as utf8 strings\n  // If you don&#39;t set an encoding, then you&#39;ll get Buffer objects\n  req.setEncoding(&#39;utf8&#39;);\n\n  // Readable streams emit &#39;data&#39; events once a listener is added\n  req.on(&#39;data&#39;, function (chunk) {\n    body += chunk;\n  })\n\n  // the end event tells you that you have entire body\n  req.on(&#39;end&#39;, function () {\n    try {\n      var data = JSON.parse(body);\n    } catch (er) {\n      // uh oh!  bad json!\n      res.statusCode = 400;\n      return res.end(&#39;error: &#39; + er.message);\n    }\n\n    // write back something interesting to the user:\n    res.write(typeof data);\n    res.end();\n  })\n})\n\nserver.listen(1337);\n\n// $ curl localhost:1337 -d &#39;{}&#39;\n// object\n// $ curl localhost:1337 -d &#39;&quot;foo&quot;&#39;\n// string\n// $ curl localhost:1337 -d &#39;not json&#39;\n// error: Unexpected token o</code></pre>\n",
          "classes": [
            {
              "textRaw": "Class: stream.Readable",
              "type": "class",
              "name": "stream.Readable",
              "desc": "<!--\nThe Readable stream interface is the abstraction for a *source* of\ndata that you are reading from.  In other words, data comes *out* of a\nReadable stream.\n-->\n\n<p>Readable ストリームのインターフェースは、あなたが読み込むデータの抽象的な\n<em>発生源</em> です。言い換えると、データは Readable ストリームから <em>出て</em> きます。\n\n</p>\n<!--\nA Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.\n-->\n\n<p>Readable ストリームは、あなたがデータを受け取る準備ができたと指示するまでは、\nデータの生成を開始しません。\n\n</p>\n<!--\nReadable streams have two \"modes\": a **flowing mode** and a **non-flowing\nmode**.  When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible.  In non-flowing\nmode, you must explicitly call `stream.read()` to get chunks of data\nout.\n-->\n\n<p>Readable ストリームは二つの &quot;モード&quot;: <strong>flowing モード</strong> と\n<strong>non-flowing モード</strong> を持っています。\nflowing モードに入ると、データは下層のシステムから読み込まれると、\n可能な限り素早くあなたのプログラムに届けられます。\nnon-flowing モードでは、データの断片を取り出すために、明示的に\n<code>stream.read()</code> を呼び出す必要があります。\n\n</p>\n<!--\nExamples of readable streams include:\n-->\n\n<p>Readable ストリームを含む例:\n\n</p>\n<!--\n* [http responses, on the client](http.html#http_http_incomingmessage)\n* [http requests, on the server](http.html#http_http_incomingmessage)\n* [fs read streams](fs.html#fs_class_fs_readstream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdout and stderr][]\n* [process.stdin][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_http_incomingmessage\"">クライアントの http レスポンス</a></li>\n<li><a href="\"http.html#http_http_incomingmessage\"">サーバの http リクエスト</a></li>\n<li><a href="\"fs.html#fs_class_fs_readstream\"">fs の ReadStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li>[child_process の標準出力と標準エラー出力][]</li>\n<li>[process.stdin][]</li>\n</ul>\n",
              "events": [
                {
                  "textRaw": "Event: 'readable'",
                  "type": "event",
                  "name": "readable",
                  "desc": "<!--\nWhen a chunk of data can be read from the stream, it will emit a\n`'readable'` event.\n-->\n\n<p>ストリームからデータの断片を読み込むことが可能となった時、\n<code>&#39;readable&#39;</code> イベントが生成されます。\n\n</p>\n<!--\nIn some cases, listening for a `'readable'` event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn't already.\n-->\n\n<p>あるケースでは、<code>&#39;readable&#39;</code> イベントを監視することは下層のシステムからデータを内部バッファへ読み込む原因となります (それがまだ行われていなかった場合)。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, function() {\n  // there is some data to read now\n})</code></pre>\n<!--\nOnce the internal buffer is drained, a `readable` event will fire\nagain when more data is available.\n-->\n\n<p>内部バッファが空になると、データが利用可能になった時に\n<code>&#39;readable&#39;</code> イベントは再び生成されます。\n\n</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'data'",
                  "type": "event",
                  "name": "data",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk of data.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} データの断片。</li>\n</ul>\n<!--\nIf you attach a `data` event listener, then it will switch the stream\ninto flowing mode, and data will be passed to your handler as soon as\nit is available.\n-->\n\n<p><code>&#39;data&#39;</code> イベントのリスナを追加すると、ストリームは flowing モードに切り替わり、\nデータは利用可能になるとすぐにあなたのハンドラに渡されます。\n\n</p>\n<!--\nIf you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.\n-->\n\n<p>ストリームから出てくる全てのデータをできるだけ素早く欲しいのなら、\nこれが最善の方法です。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n})</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'end'",
                  "type": "event",
                  "name": "end",
                  "desc": "<!--\nThis event fires when no more data will be provided.\n-->\n\n<p>このイベントは、提供するデータがもう無くなった場合に生成されます。\n\n</p>\n<!--\nNote that the `end` event **will not fire** unless the data is\ncompletely consumed.  This can be done by switching into flowing mode,\nor by calling `read()` repeatedly until you get to the end.\n-->\n\n<p><code>&#39;end&#39;</code> イベントはデータが完全に消費されるまでは <strong>生成されない</strong>\nことに注意してください。\nそれは flowing モードに切り替えることによって、または終わりに達するまで\n<code>read()</code> を繰り返し呼び出すことによって達成することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n})\nreadable.on(&#39;end&#39;, function() {\n  console.log(&#39;there will be no more data.&#39;);\n});</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'close'",
                  "type": "event",
                  "name": "close",
                  "desc": "<!--\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n-->\n\n<p>下層のリソース (例えば背後のファイル記述子) がクローズされた時に生成されます。\n全てのストリームがこのイベントを発生するわけではありません。\n\n</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "desc": "<!--\nEmitted if there was an error receiving data.\n-->\n\n<p>データの受信でエラーがあると生成されます。\n\n</p>\n",
                  "params": []
                }
              ],
              "methods": [
                {
                  "textRaw": "readable.read([size])",
                  "type": "method",
                  "name": "read",
                  "desc": "<!--\n* `size` {Number} Optional argument to specify how much data to read.\n* Return {String | Buffer | null}\n-->\n\n<ul>\n<li><code>size</code> {Number} どれだけのデータを読み込むか指定するオプションの引数。</li>\n<li>Return {String | Buffer | null}</li>\n</ul>\n<!--\nThe `read()` method pulls some data out of the internal buffer and\nreturns it.  If there is no data available, then it will return\n`null`.\n-->\n\n<p><code>read()</code> メソッドは内部バッファからデータを取り出して返します。\nもし利用可能なデータが無ければ、<code>null</code> を返します。\n\n</p>\n<!--\nIf you pass in a `size` argument, then it will return that many\nbytes.  If `size` bytes are not available, then it will return `null`.\n-->\n\n<p><code>size</code> 引数を指定すると、その長さ (バイト数または文字数) のデータを返します。\nもし <code>size</code> で指定された長さのデータが揃っていない場合は <code>null</code> を返します。\n\n</p>\n<!--\nIf you do not specify a `size` argument, then it will return all the\ndata in the internal buffer.\n-->\n\n<p><code>size</code> 引数を指定しなかった場合は、内部バッファにある全てのデータが返されます。\n\n</p>\n<!--\nThis method should only be called in non-flowing mode.  In\nflowing-mode, this method is called automatically until the internal\nbuffer is drained.\n-->\n\n<p>このメソッドは non-flowing モードの場合に限って呼び出されるべきです。\nflowing モードでは、内部バッファが空になるまで\nこのメソッドは自動的に呼び出されます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, function() {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  }\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "size",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.setEncoding(encoding)",
                  "type": "method",
                  "name": "setEncoding",
                  "desc": "<!--\n* `encoding` {String} The encoding to use.\n-->\n\n<ul>\n<li><code>encoding</code> {String} 使用するエンコーディング。</li>\n</ul>\n<!--\nCall this function to cause the stream to return strings of the\nspecified encoding instead of Buffer objects.  For example, if you do\n`readable.setEncoding('utf8')`, then the output data will be\ninterpreted as UTF-8 data, and returned as strings.  If you do\n`readable.setEncoding('hex')`, then the data will be encoded in\nhexadecimal string format.\n-->\n\n<p>この関数を呼び出すと、ストリームは Buffer オブジェクトの代わりに\n指定されたエンコーディングによる文字列を返すようになります。\n例えば、<code>readable.setEncoding(&#39;utf8&#39;)</code> とすると、得られるデータは\nUTF-8 のデータとして解釈され、文字列が返されます。\n<code>readable.setEncoding(&#39;hex&#39;)</code> とすると、データは 16 進フォーマットの\n文字列にエンコードされます。\n\n</p>\n<!--\nThis properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled `buf.toString(encoding)` on them.  If you want to read the data\nas strings, always use this method.\n-->\n\n<p>これは、Buffer を直接取得して単純に <code>buf.toString(encoding)</code>\nを呼び出した場合は潜在的にめちゃくちゃになるのとは異なり、\nマルチバイト文字を正しく扱います。\nデータを文字列として読み込みたければ、常にこのメソッドを使用してください。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.setEncoding(&#39;utf8&#39;);\nreadable.on(&#39;data&#39;, function(chunk) {\n  assert.equal(typeof chunk, &#39;string&#39;);\n  console.log(&#39;got %d characters of string data&#39;, chunk.length);\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "encoding"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.resume()",
                  "type": "method",
                  "name": "resume",
                  "desc": "<!--\nThis method will cause the readable stream to resume emitting `data`\nevents.\n-->\n\n<p>このメソッドは Readable ストリームが <code>&#39;data&#39;</code> イベントの生成を\n再開するようにします。\n\n</p>\n<!--\nThis method will switch the stream into flowing-mode.  If you do *not*\nwant to consume the data from a stream, but you *do* want to get to\nits `end` event, you can call `readable.resume()` to open the flow of\ndata.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えます。\nもしストリームからのデータを消費する必要が <em>なく</em>、しかし <code>&#39;end&#39;</code> イベントを\n受け取る必要が <em>ある</em> なら、<code>readable.resume()</code> を呼び出してデータのフローを\n開くことができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on(&#39;end&#39;, function(chunk) {\n  console.log(&#39;got to the end, but did not read anything&#39;);\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "readable.pause()",
                  "type": "method",
                  "name": "pause",
                  "desc": "<!--\nThis method will cause a stream in flowing-mode to stop emitting\n`data` events.  Any data that becomes available will remain in the\ninternal buffer.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えて、\n<code>&#39;data&#39;</code> イベントの生成を中断します。\n利用可能になったデータは内部バッファの中に残ります。\n\n</p>\n<!--\nThis method is only relevant in flowing mode.  When called on a\nnon-flowing stream, it will switch into flowing mode, but remain\npaused.\n-->\n\n<p>このメソッドは flowing モードにだけ関連します。\nnon-flowing モードのストリームで呼ばれた場合は、flowing モードに切り替わり、\n残りのデータは休止します。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, function(chunk) {\n  console.log(&#39;got %d bytes of data&#39;, chunk.length);\n  readable.pause();\n  console.log(&#39;there will be no more data for 1 second&#39;);\n  setTimeout(function() {\n    console.log(&#39;now data will start flowing again&#39;);\n    readable.resume();\n  }, 1000);\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "readable.pipe(destination, [options])",
                  "type": "method",
                  "name": "pipe",
                  "* `destination` {[Writable][] Stream} The destination for writing data\n* `options` {Object} Pipe options\n  * `end` {Boolean} End the writer when the reader ends. Default": "`true`",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`destination` {[Writable][] Stream} データの書き込み先。 ",
                          "name": "destination",
                          "type": "[Writable][] Stream",
                          "desc": "データの書き込み先。"
                        },
                        {
                          "textRaw": "`options` {Object} パイプオプション ",
                          "options": [
                            {
                              "textRaw": "`end` {Boolean} 読み込み元が終了すると書き込み先を終了します。 デフォルトは `true` ",
                              "name": "end",
                              "type": "Boolean",
                              "desc": "読み込み元が終了すると書き込み先を終了します。 デフォルトは `true`"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "パイプオプション",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "destination"
                        },
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nThis method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.\n-->\n\n<p>このメソッドは Readable ストリームから全てのデータを引き出し、\n与えられた行き先に書き込みます。\n高速な Readable ストリームによって出力先が圧迫されないように、\n自動的にフロー制御を行います。\n\n</p>\n<!--\nMultiple destinations can be piped to safely.\n-->\n\n<p>複数の出力先を安全に連結することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;\nreadable.pipe(writable);</code></pre>\n<!--\nThis function returns the destination stream, so you can set up pipe\nchains like so:\n-->\n\n<p>この関数は出力先となるストリーム返すので、このようにパイプのチェーンを\n組み立てることができます。\n\n</p>\n<pre><code class="\"javascript\"">var r = fs.createReadStream(&#39;file.txt&#39;);\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream(&#39;file.txt.gz&#39;);\nr.pipe(z).pipe(w);</code></pre>\n<!--\nFor example, emulating the Unix `cat` command:\n-->\n\n<p>Unix の <code>cat</code> コマンドをエミュレートする例:\n\n</p>\n<pre><code class="\"javascript\"">process.stdin.pipe(process.stdout);</code></pre>\n<!--\nBy default [`end()`][] is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n-->\n\n<p>デフォルトでは、出力先の [<code>end()</code>][] は入力元のストリームで\n<code>&#39;end&#39;</code> が生成された時に呼び出されます。そのため、<code>destination</code>\nはもう書き込み可能ではなくなります。\n<code>{end: false }</code> を <code>options</code> として渡すことにより、出力先ストリームを\nオープンしたままにしておくことができます。\n\n</p>\n<!--\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n-->\n\n<p>これは <code>writer</code> をオープンしたままにすることにより、最後に\n<code>&quot;Goodbye&quot;</code> と書き込むことができます。\n\n</p>\n<pre><code class="\"javascript\"">reader.pipe(writer, { end: false });\nreader.on(&#39;end&#39;, function() {\n  writer.end(&#39;Goodbye\\n&#39;);\n});</code></pre>\n<!--\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n-->\n\n<p><code>process.stderr</code> および <code>process.stdout</code> は、オプションの指定に関係なく、\nプロセスが終了するまで決してクローズされないことに注意してください。\n\n</p>\n"
                },
                {
                  "textRaw": "readable.unpipe([destination])",
                  "type": "method",
                  "name": "unpipe",
                  "desc": "<!--\n* `destination` {[Writable][] Stream} Optional specific stream to unpipe\n-->\n\n<ul>\n<li><code>destination</code> {[Writable][] Stream} オプションのパイプを解除するストリーム</li>\n</ul>\n<!--\nThis method will remove the hooks set up for a previous `pipe()` call.\n-->\n\n<p>このメソッドは以前の <code>pipe()</code> 呼び出しで設定されたフックを取り除きます。\n\n</p>\n<!--\nIf the destination is not specified, then all pipes are removed.\n-->\n\n<p><code>destination</code> が指定されなかった場合は、全てのパイプが取り除かれます。\n\n</p>\n<!--\nIf the destination is specified, but no pipe is set up for it, then\nthis is a no-op.\n-->\n\n<p><code>destination</code> が指定されたものの、それがパイプされていなかった場合、\nこれは何もしません。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;,\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(function() {\n  console.log(&#39;stop writing to file.txt&#39;);\n  readable.unpipe(writable);\n  console.log(&#39;manually close the file stream&#39;);\n  writable.end();\n}, 1000);</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "destination",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.unshift(chunk)",
                  "type": "method",
                  "name": "unshift",
                  "desc": "<!--\n* `chunk` {Buffer | String} Chunk of data to unshift onto the read queue\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} 読み込みキューの先頭に戻されるデータの断片</li>\n</ul>\n<!--\nThis is useful in certain cases where a stream is being consumed by a\nparser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.\n-->\n\n<p>これはストリームがパーサによって消費されるケースにおいて有用です。\nそれはソースから楽観的に取り出したデータを「消費しなかった」ことにして、\nストリームが他のところにデータを渡せるようにする場合に必要です。\n\n</p>\n<!--\nIf you find that you must often call `stream.unshift(chunk)` in your\nprograms, consider implementing a [Transform][] stream instead.  (See API\nfor Stream Implementors, below.)\n-->\n\n<p><code>stream.unshift(chunk)</code> を頻繁に呼び出さなくてはならないとしたら、\n代わりに [Transform][] ストリームを実装することを検討してください\n(後述する [ストリーム実装者向けの API][] を参照してください)。\n\n</p>\n<pre><code class="\"javascript\"">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nvar StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on(&#39;error&#39;, callback);\n  stream.on(&#39;readable&#39;, onReadable);\n  var decoder = new StringDecoder(&#39;utf8&#39;);\n  var header = &#39;&#39;;\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join(&#39;\\n\\n&#39;);\n        var buf = new Buffer(remaining, &#39;utf8&#39;);\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener(&#39;error&#39;, callback);\n        stream.removeListener(&#39;readable&#39;, onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.wrap(stream)",
                  "type": "method",
                  "name": "wrap",
                  "desc": "<!--\n* `stream` {Stream} An \"old style\" readable stream\n-->\n\n<ul>\n<li><code>stream</code> {Stream} 「古いスタイル」の Readable ストリーム</li>\n</ul>\n<!--\nVersions of Node prior to v0.10 had streams that did not implement the\nentire Streams API as it is today.  (See \"Compatibility\" below for\nmore information.)\n-->\n\n<p>v0.10 より前のバージョンの Node には、今日の全ストリーム API を実装していない\nストリームがありました (より詳細は後述する「[互換性][]」を参照してください)。\n\n</p>\n<!--\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a [Readable][] stream that uses the old stream\nas its data source.\n-->\n\n<p>もし、<code>&#39;data&#39;</code> イベントを生成し、アドバイスだけを行う <code>pause()</code>\nメソッドを持つ、古い Node ライブラリを使っているなら、\n<code>wrap()</code> メソッドは古いストリームをデータソースとして使用する\n[Readable][] ストリームを作成します。\n\n</p>\n<!--\nYou will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node programs and libraries.\n-->\n\n<p>この関数を呼び出す必要は滅多にありませんが、これは古い Node\nプログラム及びライブラリと相互作用するための利便性のために存在します。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code class="\"javascript\"">var OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nvar oreader = new OldReader;\nvar Readable = require(&#39;stream&#39;).Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, function() {\n  myReader.read(); // etc.\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "stream"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<!--\nThe Writable stream interface is an abstraction for a *destination*\nthat you are writing data *to*.\n-->\n\n<p>Writable ストリームのインターフェースは、あなたがデータを書き込む抽象的な\n<em>行き先</em> です。\n\n</p>\n<!--\nExamples of writable streams include:\n-->\n\n<p>Writable ストリームを含む例:\n\n</p>\n<!--\n* [http requests, on the client](http.html#http_class_http_clientrequest)\n* [http responses, on the server](http.html#http_class_http_serverresponse)\n* [fs write streams](fs.html#fs_class_fs_writestream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdin](child_process.html#child_process_child_stdin)\n* [process.stdout][], [process.stderr][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_class_http_clientrequest\"">クライアントの http リクエスト</a></li>\n<li><a href="\"http.html#http_class_http_serverresponse\"">サーバの http レスポンス</a></li>\n<li><a href="\"fs.html#fs_class_fs_writestream\"">fs の WriteStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li><a href="\"child_process.html#child_process_child_stdin\"">child_process の標準入力</a></li>\n<li>[process.stdout][], [process.stderr][]</li>\n</ul>\n",
              "methods": [
                {
                  "textRaw": "writable.write(chunk, [encoding], [callback])",
                  "type": "method",
                  "name": "write",
                  "desc": "<!--\n* `chunk` {String | Buffer} The data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Callback for when this chunk of data is flushed\n* Returns: {Boolean} True if the data was handled completely.\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} 書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} データが掃き出された時に呼び出されるコールバック</li>\n<li>Returns: {Boolean} データが完全に処理された場合は <code>true</code>。</li>\n</ul>\n<!--\nThis method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.\n-->\n\n<p>このメソッドはデータを下層のシステムに書き込み、データが完全に処理されると\n与えられたコールバックを一度だけ呼び出します。\n\n</p>\n<!--\nThe return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n`false`.  Otherwise, it will return `true`.\n-->\n\n<p>戻り値は書き込みをすぐに続けていいかどうかを示します。\nもしデータが内部にバッファリングされなければならないなら <code>false</code> を返します。\nそうでなければ <code>true</code> を返します。\n\n</p>\n<!--\nThis return value is strictly advisory.  You MAY continue to write,\neven if it returns `false`.  However, writes will be buffered in\nmemory, so it is best not to do this excessively.  Instead, wait for\nthe `drain` event before writing more data.\n-->\n\n<p>この戻り値は完全にアドバイス的です。\nもしこれが <code>false</code> を返しても、あなたは書き込みを続けることが「できます」。\nしかしながら、書き込まれたデータはメモリにバッファリングされるため、\nこれを過剰にしないことが最善です。\n代わりに、より多くのデータを書く前に <code>&#39;drain&#39;</code> イベントを待機してください。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "writable.end([chunk], [encoding], [callback])",
                  "type": "method",
                  "name": "end",
                  "desc": "<!--\n* `chunk` {String | Buffer} Optional data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Optional callback for when the stream is finished\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} オプションの書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} ストリームが終了時に呼び出される、\nオプションのコールバック</li>\n</ul>\n<!--\nCall this method when no more data will be written to the stream.  If\nsupplied, the callback is attached as a listener on the `finish` event.\n-->\n\n<p>これ以上データをストリームに書き込まない場合に呼び出してください。\nコールバックが与えられた場合、それは <code>&#39;finish&#39;</code> イベントのリスナとして\nアタッチされます。\n\n</p>\n<!--\nCalling [`write()`][] after calling [`end()`][] will raise an error.\n-->\n\n<p>[<code>end()</code>][] を呼び出した後で [<code>write()</code>][] を呼び出すとエラーになります。\n\n</p>\n<pre><code class="\"javascript\"">// write &#39;hello, &#39; and then end with &#39;world!&#39;\nhttp.createServer(function (req, res) {\n  res.write(&#39;hello, &#39;);\n  res.end(&#39;world!&#39;);\n  // writing more now is not allowed!\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk",
                          "optional": true
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ]
                }
              ],
              "events": [
                {
                  "textRaw": "Event: 'drain'",
                  "type": "event",
                  "name": "drain",
                  "desc": "<!--\nIf a [`writable.write(chunk)`][] call returns false, then the `drain`\nevent will indicate when it is appropriate to begin writing more data\nto the stream.\n-->\n\n<p>[<code>write(chunk, encoding, callback)</code>][] の呼び出しが <code>false</code> を返した場合、\nより多くのデータをいつストリームに書き始めるのが適切かを\n<code>&#39;drain&#39;</code> イベントによって示します。\n\n</p>\n<pre><code class="\"javascript\"">// Write the data to the supplied writable stream 1MM times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don&#39;t pass the callback, because we&#39;re not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once(&#39;drain&#39;, write);\n    }\n  }\n}</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'finish'",
                  "type": "event",
                  "name": "finish",
                  "desc": "<!--\nWhen the [`end()`][] method has been called, and all data has been flushed\nto the underlying system, this event is emitted.\n-->\n\n<p>[<code>end()</code>][] メソッドが呼び出されて、全てのデータが下層のシステムに\n掃き出されると、このイベントが生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write(&#39;hello, #&#39; + i + &#39;!\\n&#39;);\n}\nwriter.end(&#39;this is the end\\n&#39;);\nwriter.on(&#39;finish&#39;, function() {\n  console.error(&#39;all writes are now complete.&#39;);\n});</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'pipe'",
                  "type": "event",
                  "name": "pipe",
                  "desc": "<!--\n* `src` {[Readable][] Stream} source stream that is piping to this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームにつながれた\n入力元のストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the `pipe()` method is called on a readable\nstream, adding this writable to its set of destinations.\n-->\n\n<p>これは、Readable ストリームの <code>pipe()</code> メソッドが呼び出されて、\nこの Writable ストリームが出力先として加えられた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;pipe&#39;, function(src) {\n  console.error(&#39;something is piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'unpipe'",
                  "type": "event",
                  "name": "unpipe",
                  "desc": "<!--\n* `src` {[Readable][] Stream} The source stream that [unpiped][] this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームと[切り離された][]\n入力元の Readable ストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the [`unpipe()`][] method is called on a\nreadable stream, removing this writable from its set of destinations.\n-->\n\n<p>これは、Readable ストリームで [<code>unpipe()</code>][] メソッドが呼び出され、\nこの Writable ストリームが出力先から取り除かれた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on(&#39;unpipe&#39;, function(src) {\n  console.error(&#39;something has stopped piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "desc": "<!--\nEmitted if there was an error when writing or piping data.\n-->\n\n<p>データの書き込み中またはパイプ中にエラーが発生した場合に生成されます。\n\n</p>\n",
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<!--\nDuplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Duplex ストリームは [Readable][] と [Writable][] 両方のインターフェースを\n実装したストリームです。使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Duplex streams include:\n-->\n\n<p>Duplex ストリームを含む例:\n\n</p>\n<!--\n* [tcp sockets][]\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[tcp のソケット][]</li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<!--\nTransform streams are [Duplex][] streams where the output is in some way\ncomputed from the input.  They implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Transform ストリームは、入力から何らかの方法で出力が計算される [Duplex][]\nストリームです。\nそれらは [Readable][] と [Writable][] 両方のインターフェースを実装します。\n使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Transform streams include:\n-->\n\n<p>Transform ストリームを含む例:\n\n</p>\n<!--\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
            }
          ]
        },
        {
          "textRaw": "API for Stream Implementors",
          "name": "API for Stream Implementors",
          "type": "misc",
          "desc": "<!--\nTo implement any sort of stream, the pattern is the same:\n-->\n\n<p>どのストリームを実装する場合でも、パターンは同じです:\n\n</p>\n<!--\n1. Extend the appropriate parent class in your own subclass.  (The\n   [`util.inherits`][] method is particularly helpful for this.)\n2. Call the appropriate parent class constructor in your constructor,\n   to be sure that the internal mechanisms are set up properly.\n2. Implement one or more specific methods, as detailed below.\n-->\n\n<ol>\n<li>それぞれの親クラスを拡張して、独自のサブクラスを作成する\n(特に [<code>util.inherits</code>][] メソッドはそのために役立ちます)。</li>\n<li>内部のメカニズムがきちんとセットアップされることを確実にするために、\nサブクラスのコンストラクタの中から親クラスのコンストラクタを呼び出す。</li>\n<li>以下で詳述される、いくつかの特別なメソッドを実装する。</li>\n</ol>\n<!--\nThe class to extend and the method(s) to implement depend on the sort\nof stream class you are writing:\n-->\n\n<p>拡張するクラスと実装するメソッドは、あなたが書こうとしているストリームの種類に\n依存します。\n\n</p>\n<!--\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>Use-case</p>\n      </th>\n      <th>\n        <p>Class</p>\n      </th>\n      <th>\n        <p>Method(s) to implement</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>Reading only</p>\n    </td>\n    <td>\n      <p>[Readable](#stream_class_stream_readable_1)</p>\n    </td>\n    <td>\n      <p><code>[_read][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Writing only</p>\n    </td>\n    <td>\n      <p>[Writable](#stream_class_stream_writable_1)</p>\n    </td>\n    <td>\n      <p><code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Reading and writing</p>\n    </td>\n    <td>\n      <p>[Duplex](#stream_class_stream_duplex_1)</p>\n    </td>\n    <td>\n      <p><code>[_read][]</code>, <code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Operate on written data, then read the result</p>\n    </td>\n    <td>\n      <p>[Transform](#stream_class_stream_transform_1)</p>\n    </td>\n    <td>\n      <p><code>_transform</code>, <code>_flush</code></p>\n    </td>\n  </tr>\n</table>\n-->\n\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>ユースケース</p>\n      </th>\n      <th>\n        <p>クラス</p>\n      </th>\n      <th>\n        <p>実装するメソッド</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>読み込みのみ</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_readable_1\"">Readable</a></p>\n    </td>\n    <td>\n      <p><code>[_read][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>書き込みのみ</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_writable_1\"">Writable</a></p>\n    </td>\n    <td>\n      <p><code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>読み込みと書き込み</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_duplex_1\"">Duplex</a></p>\n    </td>\n    <td>\n      <p><code>[_read][]</code>, <code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>書き込まれたデータを変換し、その結果を読み込む</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_transform_1\"">Transform</a></p>\n    </td>\n    <td>\n      <p><code>[_transform][]</code>, <code>[_flush][]</code></p>\n    </td>\n  </tr>\n</table>\n\n<!--\nIn your implementation code, it is very important to never call the\nmethods described in [API for Stream Consumers][] above.  Otherwise, you\ncan potentially cause adverse side effects in programs that consume\nyour streaming interfaces.\n-->\n\n<p>あなたの実装コードの中では、決して [ストリーム利用者のための API][]\nで説明されたメソッドを呼び出さないことがとても重要です。\nそうでなければ、あなたのストリーミングインターフェースを利用するプログラムに\n有害な副作用を引き起こす原因となり得ます。\n\n</p>\n",
          "examples": [
            {
              "textRaw": "Class: stream.Readable",
              "type": "example",
              "name": "stream.Readable",
              "desc": "<!--\n`stream.Readable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_read(size)`][] method.\n-->\n\n<p><code>stream.Readable</code> は抽象クラスで、下層の実装として [<code>_read(size)</code>][]\nメソッドを実装することで拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nstreams in your programs.  What follows is an explanation of how to\nimplement Readable streams in your programs.\n-->\n\n<p>プログラムの中で Readable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Readable ストリームを\n実装する方法の説明です。\n\n</p>\n<h4>Example: A Counting Stream</h4>\n<!--\nThis is a basic example of a Readable stream.  It emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.\n-->\n\n<p>これは Readable ストリームの基本的な例です。\nそれは 1 から 1,000,000 までの数を昇順で生成し、そして終了します。\n\n</p>\n<pre><code class="\"javascript\"">var Readable = require(&#39;stream&#39;).Readable;\nvar util = require(&#39;util&#39;);\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i &gt; this._max)\n    this.push(null);\n  else {\n    var str = &#39;&#39; + i;\n    var buf = new Buffer(str, &#39;ascii&#39;);\n    this.push(buf);\n  }\n};</code></pre>\n<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>\n<!--\nThis is similar to the `parseHeader` function described above, but\nimplemented as a custom stream.  Also, note that this implementation\ndoes not convert the incoming data to a string.\n-->\n\n<p>これは前に説明した <code>parseHeader</code> 関数とよく似ていますが、\n独自のストリームとして実装されています。\nまた、この実装は入ってくるデータを文字列に変換しないことに注意してください。\n\n</p>\n<!--\nHowever, this would be better implemented as a [Transform][] stream.  See\nbelow for a better implementation.\n-->\n\n<p>しかしながら、これは [Transform][] ストリームを使うことでよりうまく実装できます。\n後述のよりよい実装を参照してください。\n\n</p>\n<pre><code class="\"javascript\"">// A parser for a simple data protocol.\n// The &quot;header&quot; is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// NOTE: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal.  See the\n// alternative example below under the Transform section.\n\nvar Readable = require(&#39;stream&#39;).Readable;\nvar util = require(&#39;util&#39;);\n\nutil.inherits(SimpleProtocol, Readable);\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on(&#39;end&#39;, function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on(&#39;readable&#39;, function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn&#39;t have data, we don&#39;t have data yet.\n    if (chunk === null)\n      return this.push(&#39;&#39;);\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // &#39;\\n&#39;\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push(&#39;&#39;);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit(&#39;header&#39;, this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit &#39;header&#39;\n// with the parsed header data.</code></pre>\n",
              "methods": [
                {
                  "textRaw": "new stream.Readable([options])",
                  "type": "method",
                  "name": "Readable",
                  "* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default": "16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n.  Default=false",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} (任意) ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} 下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。 ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。"
                            },
                            {
                              "textRaw": "`encoding` {String} 指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。 ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。 ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "(任意)",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Readable class, make sure to call the\nReadable constructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Readable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
                },
                {
                  "textRaw": "readable.\\_read(size)",
                  "type": "method",
                  "name": "\\_read",
                  "desc": "<!--\n* `size` {Number} Number of bytes to read asynchronously\n-->\n\n<ul>\n<li><code>size</code> {Number} 非同期に読み込むバイト数</li>\n</ul>\n<!--\nNote: **Implement this function, but do NOT call it directly.**\n-->\n\n<p>注意: <strong>この関数を実装してください、しかし直接呼び出さないでください。</strong>\n\n</p>\n<!--\nThis function should NOT be called directly.  It should be implemented\nby child classes, and only called by the internal Readable class\nmethods.\n-->\n\n<p>この関数は直接呼び出すべきではありません。\nこれはサブクラスで実装されるべきであり、Readable クラスの内部から\n呼び出されるべきです。\n\n</p>\n<!--\nAll Readable stream implementations must provide a `_read` method to\nfetch data from the underlying resource.\n-->\n\n<p>全ての Readable ストリームは、下層のリソースからデータを\n取得するために <code>_read()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<!--\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n-->\n\n<p>データが利用可能になれば、<code>readable.push(chunk)</code> を呼び出すことで\nそれを読み込みキューに追加します。\n<code>push()</code> が false を返した場合は、読み込みを止めるべきです。\n<code>_read()</code> が再び呼び出された時が、さらに多くのデータを追加を開始すべき時です。\n\n</p>\n<!--\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling [`stream.push(chunk)`][].\n-->\n\n<p><code>size</code> 引数はアドバイス的です。\n&quot;read()&quot; が一回の呼び出しでデータを返す実装では、\nどれだけのデータを取得すべきか知るためにこれを使うことができます。\nTCPやTLSなど、それに関連しない実装ではこの引数は無視され、\n利用可能になったデータをシンプルに提供するかもしれません。\nたとえば [<code>stream.push(chunk)</code>][] が呼び出されるより前に、\n<code>size</code> バイトが利用可能になるまで「待つ」必要はありません。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "size"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.push(chunk, [encoding])",
                  "type": "method",
                  "name": "push",
                  "desc": "<!--\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* `encoding` {String} Encoding of String chunks.  Must be a valid\n  Buffer encoding, such as `'utf8'` or `'ascii'`\n* return {Boolean} Whether or not more pushes should be performed\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | null | String} 読み込みキューにプッシュされる、\nデータのチャンク</li>\n<li><code>encoding</code> {String} 文字列チャンクのエンコーディング。\n<code>&#39;utf8&#39;</code> や <code>&#39;ascii&#39;</code> など、Buffer の正しいエンコーディングの必要があります。</li>\n<li>return {Boolean} さらにプッシュしてもいいかどうか</li>\n</ul>\n<!--\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable streams.**\n-->\n\n<p>注意: <strong>この関数は Readable の実装から呼び出されるべきものであり、\nReadable ストリームの利用者が呼び出すべきではありません。</strong>\n\n</p>\n<!--\nThe `_read()` function will not be called again until at least one\n`push(chunk)` call is made.\n-->\n\n<p>少なくとも一回は <code>push(chunk)</code> が呼び出されないと、<code>_read()</code> 関数が\n再び呼び出されることはありません。\n\n</p>\n<!--\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n-->\n\n<p><code>Readable</code> クラスは、<code>read()</code> メソッドが呼び出されることで\n後から取り出されるデータを、<code>&#39;readable&#39;</code> イベントの生成時に\n読み込みキューに入れておくことによって機能します。\n\n</p>\n<!--\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata (EOF).\n-->\n\n<p><code>push()</code> メソッドはいくつかのデータを明示的に読み込みキューに挿入します。\nもし <code>null</code> と共に呼び出されると、それはデータが終了した (EOF) ことを伝えます。\n\n</p>\n<!--\nThis API is designed to be as flexible as possible.  For example,\nyou may be wrapping a lower-level source which has some sort of\npause/resume mechanism, and a data callback.  In those cases, you\ncould wrap the low-level source object by doing something like this:\n-->\n\n<p>この API は可能な限り柔軟に設計されています。\n例えば、ある種の中断／再開メカニズムとデータのコールバックを持つ、\nより低水準のデータソースをラップするかもしれません。\nそれらのケースでは、このように低水準のソースオブジェクトを\nラップすることができます。\n\n</p>\n<pre><code class="\"javascript\"">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n  var self = this;\n\n  // Every time there&#39;s data, we push it into the internal buffer.\n  this._source.ondata = function(chunk) {\n    // if push() returns false, then we need to stop reading from source\n    if (!self.push(chunk))\n      self._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signalling `null` chunk\n  this._source.onend = function() {\n    self.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "classes": [
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<!--\n`stream.Writable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_write(chunk, encoding, callback)`][] method.\n-->\n\n<p><code>stream.Writable</code> は抽象クラスで、下層の実装として\n[<code>_write(chunk, encoding, callback)</code>][] メソッドを実装することで\n拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nwritable streams in your programs.  What follows is an explanation of\nhow to implement Writable streams in your programs.\n-->\n\n<p>プログラムの中で Writable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Writable ストリームを\n実装する方法の説明です。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Writable([options])",
                  "type": "method",
                  "name": "Writable",
                  "* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when [`write()`][] starts\n    returning false. Default": "16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to [`_write()`][].  Default=true\n  * `objectMode` {Boolean} Whether or not the `write(anyObj)` is\n    a valid operation. If set you can write arbitrary data instead\n    of only `Buffer` / `String` data.  Default=false",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} (任意) ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} [`write()`][] が `false` を返し始める バッファレベル。デフォルトは 16kb。 ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "[`write()`][] が `false` を返し始める バッファレベル。デフォルトは 16kb。"
                            },
                            {
                              "textRaw": "`decodeStrings` {Boolean} 文字列が [`_write()`][] に渡される前に バッファにデコードするかどうか。デフォルトは `true`。 ",
                              "name": "decodeStrings",
                              "type": "Boolean",
                              "desc": "文字列が [`_write()`][] に渡される前に バッファにデコードするかどうか。デフォルトは `true`。"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} `write(anyObj)` が妥当な操作かどうか。 もし `true` を設定すると、`Buffer` / `String` データのみではなく、 任意のデータを書き込むことができるようになります。 デフォルトは `false`。 ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "`write(anyObj)` が妥当な操作かどうか。 もし `true` を設定すると、`Buffer` / `String` データのみではなく、 任意のデータを書き込むことができるようになります。 デフォルトは `false`。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "(任意)",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Writable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
                },
                {
                  "textRaw": "writable.\\_write(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_write",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | Array} 書き込まれるデータ。\n<code>decodeStrings</code> オプションが <code>false</code> に設定されない限り常にバッファです。</li>\n<li><code>encoding</code> {String} チャンクが文字列の場合のエンコーディング方式。\nチャンクがバッファの場合は無視されます。\n<code>decodeStrings</code> オプションが明示的に <code>false</code> に設定されない限り、\nチャンクは <em>常に</em> バッファであるべき事に注意してください。</li>\n<li><code>callback</code> {Function} チャンクを提供する処理が終了した時に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nAll Writable stream implementations must provide a [`_write()`][]\nmethod to send data to the underlying resource.\n-->\n\n<p>全ての Writable ストリームは、下層のリソースにデータを\n送るために [<code>_write()</code>][] メソッドを提供しなければなりません。\n\n</p>\n<!--\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるべきであり、Writable クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n-->\n\n<p>コールバックは出力が成功して完了したか、エラーが発生したかを伝えるために、\n標準的な <code>callback(error)</code> パターンを使って呼び出します。\n\n</p>\n<!--\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n-->\n\n<p>コンストラクタオプションの <code>decodeStrings</code> フラグがセットされると、\n<code>chunk</code> を Buffer ではなく文字列にし、<code>encoding</code> でその文字列の\n種類を示すことができます。\nこれは、実装が文字列データのエンコーディングを最適化できるようにするためです。\n<code>decodeStrings</code> オプションを明示的に <code>false</code> に設定しない場合、\n<code>endocing</code> 引数は安全に無視することができます。\nそして <code>chunk</code> は常に Buffer であると見なせます。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<!--\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n-->\n\n<p>&quot;duplex&quot; ストリームは、TCP ソケットコネクションのように\nReadable であり Writable でもあるストリームの一種です。\n\n</p>\n<!--\nNote that `stream.Duplex` is an abstract class designed to be extended\nwith an underlying implementation of the `_read(size)` and\n[`_write(chunk, encoding, callback)`][] methods as you would with a\nReadable or Writable stream class.\n-->\n\n<p><code>stream.Duplex</code> は、Readable および Writable ストリームクラスと同様、\n下層の実装である [<code>_read(size)</code>][] および\n[<code>_write(chunk, encoding, callback)</code>][] メソッドによって拡張されるように\n設計された抽象クラスであることに注意してください。\n\n</p>\n<!--\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel\n[`_write(chunk, encoding, callback)`][] method on extension duplex classes.\n-->\n\n<p>JavaScript は複数のプロトタイプ継承を持つことができないため、\nこのクラスは Readable からプロトタイプを継承したうえで、\nWritable から寄生的な方法 (プロトタイプメンバーのコピー) を行います。\n低水準の [<code>_read(size)</code>][] および [<code>_write(chunk, encoding, callback)</code>][]\nを実装することは、Duplex クラスを拡張するユーザの責務です。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Duplex(options)",
                  "type": "method",
                  "name": "Duplex",
                  "* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default": "true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Writable および Readable のコンストラクタに渡されます。 以下のフィールドを持つこともできます: ",
                          "options": [
                            {
                              "textRaw": "`allowHalfOpen` {Boolean} デフォルトは `true`。 もし `false` に設定された場合、読み込み側が閉じられると 自動的に書き込み側も閉じられます。 ",
                              "name": "allowHalfOpen",
                              "type": "Boolean",
                              "desc": "デフォルトは `true`。 もし `false` に設定された場合、読み込み側が閉じられると 自動的に書き込み側も閉じられます。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Writable および Readable のコンストラクタに渡されます。 以下のフィールドを持つこともできます:"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Duplex</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n\n</p>\n"
                }
              ]
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<!--\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a [zlib][] stream or a\n[crypto][] stream.\n-->\n\n<p>&quot;Transform&quot; ストリームは、[zlib][] ストリームや [crypto][] ストリームのように、\n入力が何らかの方法で出力の元となっているような Duplex ストリームです。\n\n</p>\n<!--\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will produce output\nthat is either much smaller or much larger than its input.\n-->\n\n<p>出力は、入力と同じサイズ、同じ数のチャンク、同時に到着することを\n要求されません。\nたとえば、Hash ストリームは入力が終了すると一つだけのチャンクを出力します。\nzlib ストリームは、入力より小さいか、またはより大きい出力を生成します。\n\n</p>\n<!--\nRather than implement the [`_read()`][] and [`_write()`][] methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n-->\n\n<p>[<code>_read()</code>][] および [<code>_write()</code>][] メソッドの代わりに、Transform クラスでは\n<code>_transform()</code> メソッドを実装しなければなりません。\nまた、任意で <code>_flush()</code> メソッドを実装することもできます (後述)。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Transform([options])",
                  "type": "method",
                  "name": "Transform",
                  "desc": "<!--\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n-->\n\n<ul>\n<li><code>options</code> {Object} Writable および Readable のコンストラクタに渡されます。</li>\n</ul>\n<!--\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Transform</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "transform.\\_transform(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_transform",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | Array} 書き込まれるデータ。\n<code>decodeStrings</code> オプションが <code>false</code> に設定されない限り常にバッファです。</li>\n<li><code>encoding</code> {String} チャンクが文字列の場合のエンコーディング方式\n(チャンクがバッファの場合は無視されます)。</li>\n<li><code>callback</code> {Function} チャンクを提供する処理が終了した時に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるべきであり、Transform クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n-->\n\n<p>全ての Transform ストリームの実装は、入力を受け取って出力を提供するために\n<code>_transform()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n-->\n\n<p>書き込まれるバイトを処理し、読み込み可能なインタフェースに渡すなど、\nTransform クラスでしなければならないことは全て <code>_transform()</code>\nで行わなければなりません。非同期 I/O、何かの処理、その他。\n\n</p>\n<!--\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n-->\n\n<p>この入力チャンクからの出力を生成するために、<code>transform.push(outputChunk)</code>\nを 0 回以上呼び出してください。\nそれはこのチャンクの結果としてどれだけのデータを出力したいのかに依存します。\n\n</p>\n<!--\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n-->\n\n<p>現在のチャンクの処理が完全に終了した場合のみ、コールバック関数を呼び出します。\n特定の入力チャンクからの結果として、出力があるかもしれないし、\n無いかもしれないことに注意してください。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "transform.\\_flush(callback)",
                  "type": "method",
                  "name": "\\_flush",
                  "desc": "<!--\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n-->\n\n<ul>\n<li><code>callback</code> {Function} 与えられたチャンクの処理が終了した場合に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるかもしれず、Transform クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n-->\n\n<p>場合によっては、変換操作はストリームの終端でより多くのデータを\n生成する必要があります。\nたとえば、<code>Zlib</code> 圧縮ストリームは出力を最適に圧縮できるように、\nいくつかの内部状態を持ちます。\n一方、終端ではデータが完全なものになるように、\n残されたものに最善を尽くす必要があります。\n\n</p>\n<!--\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n-->\n\n<p>この場合、最後の最後 (書き込まれた全てのデータが消費された後、\nただし読み込み側の終了を知らせる <code>&#39;end&#39;</code> が生成される前) に呼び出される\n<code>_flush()</code> メソッドを実装することができます。\n<code>_transform()</code> と同様、<code>transform.push(chunk)</code> を何度 (0 回以上) でも\n適切に呼び出し、フラッシュ操作が完了した時に <code>callback</code> を呼び出します。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<h4>Example: <code>SimpleProtocol</code> parser v2</h4>\n<!--\nThe example above of a simple protocol parser can be implemented\nsimply by using the higher level [Transform][] stream class, similar to\nthe `parseHeader` and `SimpleProtocol v1` examples above.\n-->\n\n<p>前述した単純なプロトコルパーサの例は、より高水準な [Transform][] ストリームクラスを\n使うことで、さらにシンプルに実装することができます。\n前述の <code>parseHeader</code> および <code>SimpleProtocol v1</code> とよく似た例です。\n\n</p>\n<!--\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n-->\n\n<p>この例では、入力を引数で与えるのではなく、Node のストームにおける\nより慣用的なアプローチとしてパーサにパイプで送られます。\n\n</p>\n<pre><code class="\"javascript\"">var util = require(&#39;util&#39;);\nvar Transform = require(&#39;stream&#39;).Transform;\nutil.inherits(SimpleProtocol, Transform);\n\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // &#39;\\n&#39;\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit(&#39;header&#39;, this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(chunk.slice(split));\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(chunk);\n  }\n  done();\n};\n\n// Usage:\n// var parser = new SimpleProtocol();\n// source.pipe(parser)\n// Now parser is a readable stream that will emit &#39;header&#39;\n// with the parsed header data.</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.PassThrough",
              "type": "class",
              "name": "stream.PassThrough",
              "desc": "<!--\nThis is a trivial implementation of a [Transform][] stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy as a building block for novel sorts of streams.\n-->\n\n<p>これは [Transform][] ストリームの取るに足らない実装で、\n入力したバイト列を出力に単純に渡すだけです。\nこれの主な目的はサンプル及びテストですが、新しい種類のストリームのための\nビルディングブロックとして、何かと便利となるユースケースが時折存在します。\n\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Streams: Under the Hood",
          "name": "Streams: Under the Hood",
          "type": "misc",
          "miscs": [
            {
              "textRaw": "Buffering",
              "name": "Buffering",
              "type": "misc",
              "desc": "<!--\nBoth Writable and Readable streams will buffer data on an internal\nobject called `_writableState.buffer` or `_readableState.buffer`,\nrespectively.\n-->\n\n<p>Readable 及び Writable ストリームはそれぞれ、<code>_writableState.buffer</code> または\n<code>_readableState.buffer</code> と呼ばれる内部オブジェクトにデータを\nバッファリングします。\n\n</p>\n<!--\nThe amount of data that will potentially be buffered depends on the\n`highWaterMark` option which is passed into the constructor.\n-->\n\n<p>バッファリングされるデータの量は、コンストラクタに渡される <code>highWaterMark</code>\nオプションに依存します。\n\n</p>\n<!--\nBuffering in Readable streams happens when the implementation calls\n[`stream.push(chunk)`][].  If the consumer of the Stream does not call\n`stream.read()`, then the data will sit in the internal queue until it\nis consumed.\n-->\n\n<p>Readable ストリームにおけるバッファリングは、実装が [<code>stream.push(chunk)</code>][]\nを呼び出した時に起こります。\nストリームの利用者が <code>stream.read()</code> を呼び出さないと、\nデータはそれが消費されるまで内部キューに留まります。\n\n</p>\n<!--\nBuffering in Writable streams happens when the user calls\n[`stream.write(chunk)`][] repeatedly, even when `write()` returns `false`.\n-->\n\n<p>Writable ストリームにおけるバッファリングは、利用者が [<code>stream.write(chunk)</code>][]\nを繰り返し呼び出すと、<code>write()</code> が <code>false</code> を返した場合でも起こります。\n\n</p>\n<!--\nThe purpose of streams, especially with the `pipe()` method, is to\nlimit the buffering of data to acceptable levels, so that sources and\ndestinations of varying speed will not overwhelm the available memory.\n-->\n\n<p>ストリーム、特に <code>pipe()</code> メソッドの目的は、データのバッファリングを\n許容できるレベルに制限することです。そのため、様々な速度の入力元と出力先で、\n利用可能なメモリを圧迫しません。\n\n</p>\n"
            },
            {
              "textRaw": "`stream.read(0)`",
              "name": "`stream.read(0)`",
              "desc": "<!--\nThere are some cases where you want to trigger a refresh of the\nunderlying readable stream mechanisms, without actually consuming any\ndata.  In that case, you can call `stream.read(0)`, which will always\nreturn null.\n-->\n\n<p>実際にデータを消費することなく、下層の Readable ストリームのメカニズムを\nリフレッシュするきっかけが欲しくなるケースがあります。\nそのケースでは、常に <code>null</code> を返す <code>stream.read(0)</code> を呼び出すことができます。\n\n</p>\n<!--\nIf the internal read buffer is below the `highWaterMark`, and the\nstream is not currently reading, then calling `read(0)` will trigger\na low-level `_read` call.\n-->\n\n<p>内部バッファが <code>highWaterMark</code> を下回っていて、\nストリームが現在読み込み中でなければ、<code>read(0)</code> の呼び出しは低水準の\n<code>_read()</code> を呼び出すきっかけとなります。\n\n</p>\n<!--\nThere is almost never a need to do this.  However, you will see some\ncases in Node's internals where this is done, particularly in the\nReadable stream class internals.\n-->\n\n<p>これをする必要はほとんどありません。\nしかしながら Node の内部、特に Readable ストリームクラスの内部で、\nこれが使われているケースを見ることができるでしょう。\n\n</p>\n",
              "type": "misc",
              "displayName": "`stream.read(0)`"
            },
            {
              "textRaw": "`stream.push('')`",
              "name": "`stream.push('')`",
              "desc": "<!--\nPushing a zero-byte string or Buffer (when not in [Object mode][]) has an\ninteresting side effect.  Because it *is* a call to\n[`stream.push()`][], it will end the `reading` process.  However, it\ndoes *not* add any data to the readable buffer, so there's nothing for\na user to consume.\n-->\n\n<p>ゼロバイトの長さの文字列またはバッファをプッシュすると、\n([オブジェクトモード][]の場合を除き) 面白い副作用が起こります。\nそれは [<code>stream.push()</code>][] を呼び出すので、<code>reading</code> プロセスを終了します。\nしかしながら、それは読み込みバッファにどんなデータも加え <em>ない</em> ので、\nユーザが消費するものは何もありません。\n\n</p>\n<!--\nVery rarely, there are cases where you have no data to provide now,\nbut the consumer of your stream (or, perhaps, another bit of your own\ncode) will know when to check again, by calling `stream.read(0)`.  In\nthose cases, you *may* call `stream.push('')`.\n-->\n\n<p>ごくまれに、今は提供するデータが無い場合があります。しかし、<code>stream.read(0)</code>\nを呼び出すことにより、ストリームの利用者 (あるいは、もしかするとあなたの\nコードの一部) は再びチェックすべきなのがいつかを知ることができます。\nこのケースでは、<code>stream.push(&#39;&#39;)</code> を呼び出すことが <em>できます</em> 。\n\n</p>\n<!--\nSo far, the only use case for this functionality is in the\n[tls.CryptoStream][] class, which is deprecated in Node v0.12.  If you\nfind that you have to use `stream.push('')`, please consider another\napproach, because it almost certainly indicates that something is\nhorribly wrong.\n-->\n\n<p>現在の所、この機能の唯一のユースケースは v0.12 で廃止予定の\n[tls.CryptoStream][] の中にあります。\nもし <code>stream.push(&#39;&#39;)</code> を使わなければならないことになったら、それはおそらく\n何かが恐ろしく間違っていることを示すので、他の方法を検討してください。\n\n</p>\n",
              "type": "misc",
              "displayName": "`stream.push('')`"
            },
            {
              "textRaw": "Compatibility with Older Node Versions",
              "name": "Compatibility with Older Node Versions",
              "type": "misc",
              "desc": "<!--\nIn versions of Node prior to v0.10, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n-->\n\n<p>v0.10 より前のバージョンの Node では、Readable ストリームのインタフェースは\nよりシンプルでしたが、強力ではなく使いやすくもありませんでした。\n\n</p>\n<!--\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n-->\n\n<ul>\n<li><code>read()</code> メソッドが呼び出されるのを待つのではなく、\n<code>&#39;data&#39;</code> イベントがすぐに生成され始めます。\nもしデータを処理する方法を決定するためにいくらかの I/O をする\n必要がある場合、データが失われないようにするためには\nチャンクを何らかのバッファに保存しなければなりませんでした。</li>\n<li><code>pause()</code> は保証というよりはむしろ助言です。\nそれはストリームが中断された状態であったとしても、\n<code>&#39;data&#39;</code> イベントを受け取る準備が必要だということを意味します。</li>\n</ul>\n<!--\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"flowing mode\" when a `'data'` event handler is added, or\nwhen the `pause()` or `resume()` methods are called.  The effect is\nthat, even if you are not using the new `read()` method and\n`'readable'` event, you no longer have to worry about losing `'data'`\nchunks.\n-->\n\n<p>Node v0.10 から、上記で説明した Readable クラスが追加されました。\n古い Node プログラムとの後方互換性のために、Readable ストリームは\n<code>&#39;data&#39;</code> イベントのハンドラが加えられた場合や、<code>pause()</code> または\n<code>resume()</code> メソッドが読み出されると、「flowing モード」に切り替わります。\nその結果として、新しい <code>read()</code> メソッドや <code>&#39;readable&#39;</code> イベントを\n使用していなくても、もう <code>&#39;data&#39;</code> イベントのチャンクが失われることを\n心配する必要はありません。\n\n</p>\n<!--\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n-->\n\n<p>ほとんどのプログラムはこれまで通りに機能するでしょう。\nしかしながら、以下の条件でエッジケースが存在します。\n\n</p>\n<!--\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n-->\n\n<ul>\n<li><code>&#39;data&#39;</code> イベントハンドラが登録されていない。</li>\n<li><code>pause()</code> および <code>resume()</code> メソッドが呼び出されていない。</li>\n</ul>\n<!--\nFor example, consider the following code:\n-->\n\n<p>例えば、以下のコードを考えてみてください:\n\n</p>\n<pre><code class="\"javascript\"">// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an &#39;end&#39; method, but never consume the data\n  socket.on(&#39;end&#39;, function() {\n    // It will never get here.\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n}).listen(1337);</code></pre>\n<!--\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n-->\n\n<p>v0.10 より前の Node では、入ってきたデータは単純に破棄されていました。\nしかしながら、Node v0.10 以降では、ソケットは中断したままとなります。\n\n</p>\n<!--\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n-->\n\n<p>この状況の回避策は、「flowwing モード」の振る舞いへのトリガーとして\n<code>resume()</code> メソッドを呼び出すことです。\n\n</p>\n<pre><code class="\"javascript\"">// Workaround\nnet.createServer(function(socket) {\n\n  socket.on(&#39;end&#39;, function() {\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);</code></pre>\n<!--\nIn addition to new Readable streams switching into flowing-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n-->\n\n<p>新しい Readable ストリームを flowing モードに切り替えられることに加えて、\n<code>wrap()</code> メソッドを使って v0.10 より前のスタイルのストリームを\nReadable クラスでラップすることもできます。\n\n\n</p>\n"
            },
            {
              "textRaw": "Object Mode",
              "name": "Object Mode",
              "type": "misc",
              "desc": "<!--\nNormally, Streams operate on Strings and Buffers exclusively.\n-->\n\n<p>通常、ストリームは文字列またはバッファのみを扱います。\n\n</p>\n<!--\nStreams that are in **object mode** can emit generic JavaScript values\nother than Buffers and Strings.\n-->\n\n<p><strong>オブジェクトモード</strong> のストリームは、文字列及びバッファ以外の\n一般的なJavaScriptの値を扱うことができます。\n\n</p>\n<!--\nA Readable stream in object mode will always return a single item from\na call to `stream.read(size)`, regardless of what the size argument\nis.\n-->\n\n<p>オブジェクトモードの Readable ストリームは、<code>stream.read(size)</code> のサイズ引数が\nいくつであるかに関わらず、常に一つの項目を返します。\n\n</p>\n<!--\nA Writable stream in object mode will always ignore the `encoding`\nargument to `stream.write(data, encoding)`.\n-->\n\n<p>オブジェクトモードの Writable ストリームは、<code>stream.write(data, encoding)</code>\nの <code>encoding</code> 引数を常に無視します。\n\n</p>\n<!--\nThe special value `null` still retains its special value for object\nmode streams.  That is, for object mode readable streams, `null` as a\nreturn value from `stream.read()` indicates that there is no more\ndata, and [`stream.push(null)`][] will signal the end of stream data\n(`EOF`).\n-->\n\n<p>特別な値 <code>null</code> は、オブジェクトモードのストリームにおいても\n特別な値を持ちます。\nすなわち、オブジェクトモードの Readable ストリームでは、<code>stream.read()</code>\nの戻り値 <code>null</code> はもうデータが無いことを、[<code>stream.push(null)</code>][]\nはストリームデータの終端を示します (<code>EOF</code>)。\n\n</p>\n<!--\nNo streams in Node core are object mode streams.  This pattern is only\nused by userland streaming libraries.\n-->\n\n<p>Node のコアライブラリにはオブジェクトモードのストリームは存在しません。\nこのパターンはユーザランドのライブラリでのみ使われます。\n\n</p>\n<!--\nYou should set `objectMode` in your stream child class constructor on\nthe options object.  Setting `objectMode` mid-stream is not safe.\n-->\n\n<p>ストリームのサブクラスはコストラクタの <code>options</code> オブジェクトで <code>objectMode</code>\nを設定すべきです。\n<code>objectMode</code> をストリームの途中で設定することは安全ではありません。\n\n</p>\n"
            },
            {
              "textRaw": "State Objects",
              "name": "state_objects",
              "desc": "<!--\n[Readable][] streams have a member object called `_readableState`.\n[Writable][] streams have a member object called `_writableState`.\n[Duplex][] streams have both.\n-->\n\n<p>[Readable][] ストリームは <code>_readableState</code> と呼ばれるメンバを持っています。\n[Writable][] ストリームは <code>_writableState</code> と呼ばれるメンバを持っています。\n[Duplex][] ストリームは両方を持っています。\n\n</p>\n<!--\n**These objects should generally not be modified in child classes.**\nHowever, if you have a Duplex or Transform stream that should be in\n`objectMode` on the readable side, and not in `objectMode` on the\nwritable side, then you may do this in the constructor by setting the\nflag explicitly on the appropriate state object.\n-->\n\n<p><strong>通常、これらのオブジェクトはサブクラスで変更すべきではありません。</strong>\nしかしながら、もし Duplex または Transform ストリームの読み込み側が\n<code>objectMode</code> で、書き込み側が <code>objectMode</code> ではない場合、コンストラクタで\n適切なステートオブジェクトにフラグを明示的に設定することになるかもしれません。\n\n</p>\n<pre><code class="\"javascript\"">var util = require(&#39;util&#39;);\nvar StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nvar Transform = require(&#39;stream&#39;).Transform;\nutil.inherits(JSONParseStream, Transform);\n\n// Gets \\n-delimited JSON string data, and emits the parsed objects\nfunction JSONParseStream(options) {\n  if (!(this instanceof JSONParseStream))\n    return new JSONParseStream(options);\n\n  Transform.call(this, options);\n  this._writableState.objectMode = false;\n  this._readableState.objectMode = true;\n  this._buffer = &#39;&#39;;\n  this._decoder = new StringDecoder(&#39;utf8&#39;);\n}\n\nJSONParseStream.prototype._transform = function(chunk, encoding, cb) {\n  this._buffer += this._decoder.write(chunk);\n  // split on newlines\n  var lines = this._buffer.split(/\\r?\\n/);\n  // keep the last partial line buffered\n  this._buffer = lines.pop();\n  for (var l = 0; l &lt; lines.length; l++) {\n    var line = lines[l];\n    try {\n      var obj = JSON.parse(line);\n    } catch (er) {\n      this.emit(&#39;error&#39;, er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};\n\nJSONParseStream.prototype._flush = function(cb) {\n  // Just handle any leftover\n  var rem = this._buffer.trim();\n  if (rem) {\n    try {\n      var obj = JSON.parse(rem);\n    } catch (er) {\n      this.emit(&#39;error&#39;, er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};</code></pre>\n<!--\nThe state objects contain other useful information for debugging the\nstate of streams in your programs.  It is safe to look at them, but\nbeyond setting option flags in the constructor, it is **not** safe to\nmodify them.\n-->\n\n<p>ステートオブジェクトは、デバッグで役に立つストリームの状態を\n情報として持ちます。それを見ることは安全ですが、しかしコンストラクタで設定した\nオプションフラグを変更することは安全では <strong>ありません</strong>。\n\n\n</p>\n<!--\n[EventEmitter]: events.html#events_class_events_eventemitter\n[Object mode]: #stream_object_mode\n[`stream.push(chunk)`]: #stream_readable_push_chunk_encoding\n[`stream.push(null)`]: #stream_readable_push_chunk_encoding\n[`stream.push()`]: #stream_readable_push_chunk_encoding\n[`unpipe()`]: #stream_readable_unpipe_destination\n[unpiped]: #stream_readable_unpipe_destination\n[tcp sockets]: net.html#net_class_net_socket\n[zlib streams]: zlib.html\n[zlib]: zlib.html\n[crypto streams]: crypto.html\n[crypto]: crypto.html\n[tls.CryptoStream]: tls.html#tls_class_cryptostream\n[process.stdin]: process.html#process_process_stdin\n[stdout]: process.html#process_process_stdout\n[process.stdout]: process.html#process_process_stdout\n[process.stderr]: process.html#process_process_stderr\n[child process stdout and stderr]: child_process.html#child_process_child_stdout\n[API for Stream Consumers]: #stream_api_for_stream_consumers\n[API for Stream Implementors]: #stream_api_for_stream_implementors\n[Readable]: #stream_class_stream_readable\n[Writable]: #stream_class_stream_writable\n[Duplex]: #stream_class_stream_duplex\n[Transform]: #stream_class_stream_transform\n[`_read(size)`]: #stream_readable_read_size_1\n[`_read()`]: #stream_readable_read_size_1\n[_read]: #stream_readable_read_size_1\n[`writable.write(chunk)`]: #stream_writable_write_chunk_encoding_callback\n[`write(chunk, encoding, callback)`]: #stream_writable_write_chunk_encoding_callback\n[`write()`]: #stream_writable_write_chunk_encoding_callback\n[`stream.write(chunk)`]: #stream_writable_write_chunk_encoding_callback\n[`_write(chunk, encoding, callback)`]: #stream_writable_write_chunk_encoding_callback_1\n[`_write()`]: #stream_writable_write_chunk_encoding_callback_1\n[_write]: #stream_writable_write_chunk_encoding_callback_1\n[`util.inherits`]: util.html#util_util_inherits_constructor_superconstructor\n[`end()`]: #stream_writable_end_chunk_encoding_callback\n-->\n\n",
              "type": "misc",
              "displayName": "State Objects"
            }
          ]
        }
      ],
      "examples": [
        {
          "textRaw": "Class: stream.Readable",
          "type": "example",
          "name": "stream.Readable",
          "desc": "<!--\n`stream.Readable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_read(size)`][] method.\n-->\n\n<p><code>stream.Readable</code> は抽象クラスで、下層の実装として [<code>_read(size)</code>][]\nメソッドを実装することで拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nstreams in your programs.  What follows is an explanation of how to\nimplement Readable streams in your programs.\n-->\n\n<p>プログラムの中で Readable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Readable ストリームを\n実装する方法の説明です。\n\n</p>\n<h4>Example: A Counting Stream</h4>\n<!--\nThis is a basic example of a Readable stream.  It emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.\n-->\n\n<p>これは Readable ストリームの基本的な例です。\nそれは 1 から 1,000,000 までの数を昇順で生成し、そして終了します。\n\n</p>\n<pre><code class="\"javascript\"">var Readable = require(&#39;stream&#39;).Readable;\nvar util = require(&#39;util&#39;);\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i &gt; this._max)\n    this.push(null);\n  else {\n    var str = &#39;&#39; + i;\n    var buf = new Buffer(str, &#39;ascii&#39;);\n    this.push(buf);\n  }\n};</code></pre>\n<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>\n<!--\nThis is similar to the `parseHeader` function described above, but\nimplemented as a custom stream.  Also, note that this implementation\ndoes not convert the incoming data to a string.\n-->\n\n<p>これは前に説明した <code>parseHeader</code> 関数とよく似ていますが、\n独自のストリームとして実装されています。\nまた、この実装は入ってくるデータを文字列に変換しないことに注意してください。\n\n</p>\n<!--\nHowever, this would be better implemented as a [Transform][] stream.  See\nbelow for a better implementation.\n-->\n\n<p>しかしながら、これは [Transform][] ストリームを使うことでよりうまく実装できます。\n後述のよりよい実装を参照してください。\n\n</p>\n<pre><code class="\"javascript\"">// A parser for a simple data protocol.\n// The &quot;header&quot; is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// NOTE: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal.  See the\n// alternative example below under the Transform section.\n\nvar Readable = require(&#39;stream&#39;).Readable;\nvar util = require(&#39;util&#39;);\n\nutil.inherits(SimpleProtocol, Readable);\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on(&#39;end&#39;, function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on(&#39;readable&#39;, function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn&#39;t have data, we don&#39;t have data yet.\n    if (chunk === null)\n      return this.push(&#39;&#39;);\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // &#39;\\n&#39;\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push(&#39;&#39;);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit(&#39;header&#39;, this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit &#39;header&#39;\n// with the parsed header data.</code></pre>\n",
          "methods": [
            {
              "textRaw": "new stream.Readable([options])",
              "type": "method",
              "name": "Readable",
              "* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default": "16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n.  Default=false",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} (任意) ",
                      "options": [
                        {
                          "textRaw": "`highWaterMark` {Number} 下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。 ",
                          "name": "highWaterMark",
                          "type": "Number",
                          "desc": "下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。"
                        },
                        {
                          "textRaw": "`encoding` {String} 指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。 ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。"
                        },
                        {
                          "textRaw": "`objectMode` {Boolean} このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。 ",
                          "name": "objectMode",
                          "type": "Boolean",
                          "desc": "このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "(任意)",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nIn classes that extend the Readable class, make sure to call the\nReadable constructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Readable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
            },
            {
              "textRaw": "readable.\\_read(size)",
              "type": "method",
              "name": "\\_read",
              "desc": "<!--\n* `size` {Number} Number of bytes to read asynchronously\n-->\n\n<ul>\n<li><code>size</code> {Number} 非同期に読み込むバイト数</li>\n</ul>\n<!--\nNote: **Implement this function, but do NOT call it directly.**\n-->\n\n<p>注意: <strong>この関数を実装してください、しかし直接呼び出さないでください。</strong>\n\n</p>\n<!--\nThis function should NOT be called directly.  It should be implemented\nby child classes, and only called by the internal Readable class\nmethods.\n-->\n\n<p>この関数は直接呼び出すべきではありません。\nこれはサブクラスで実装されるべきであり、Readable クラスの内部から\n呼び出されるべきです。\n\n</p>\n<!--\nAll Readable stream implementations must provide a `_read` method to\nfetch data from the underlying resource.\n-->\n\n<p>全ての Readable ストリームは、下層のリソースからデータを\n取得するために <code>_read()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<!--\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n-->\n\n<p>データが利用可能になれば、<code>readable.push(chunk)</code> を呼び出すことで\nそれを読み込みキューに追加します。\n<code>push()</code> が false を返した場合は、読み込みを止めるべきです。\n<code>_read()</code> が再び呼び出された時が、さらに多くのデータを追加を開始すべき時です。\n\n</p>\n<!--\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling [`stream.push(chunk)`][].\n-->\n\n<p><code>size</code> 引数はアドバイス的です。\n&quot;read()&quot; が一回の呼び出しでデータを返す実装では、\nどれだけのデータを取得すべきか知るためにこれを使うことができます。\nTCPやTLSなど、それに関連しない実装ではこの引数は無視され、\n利用可能になったデータをシンプルに提供するかもしれません。\nたとえば [<code>stream.push(chunk)</code>][] が呼び出されるより前に、\n<code>size</code> バイトが利用可能になるまで「待つ」必要はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.push(chunk, [encoding])",
              "type": "method",
              "name": "push",
              "desc": "<!--\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* `encoding` {String} Encoding of String chunks.  Must be a valid\n  Buffer encoding, such as `'utf8'` or `'ascii'`\n* return {Boolean} Whether or not more pushes should be performed\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | null | String} 読み込みキューにプッシュされる、\nデータのチャンク</li>\n<li><code>encoding</code> {String} 文字列チャンクのエンコーディング。\n<code>&#39;utf8&#39;</code> や <code>&#39;ascii&#39;</code> など、Buffer の正しいエンコーディングの必要があります。</li>\n<li>return {Boolean} さらにプッシュしてもいいかどうか</li>\n</ul>\n<!--\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable streams.**\n-->\n\n<p>注意: <strong>この関数は Readable の実装から呼び出されるべきものであり、\nReadable ストリームの利用者が呼び出すべきではありません。</strong>\n\n</p>\n<!--\nThe `_read()` function will not be called again until at least one\n`push(chunk)` call is made.\n-->\n\n<p>少なくとも一回は <code>push(chunk)</code> が呼び出されないと、<code>_read()</code> 関数が\n再び呼び出されることはありません。\n\n</p>\n<!--\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n-->\n\n<p><code>Readable</code> クラスは、<code>read()</code> メソッドが呼び出されることで\n後から取り出されるデータを、<code>&#39;readable&#39;</code> イベントの生成時に\n読み込みキューに入れておくことによって機能します。\n\n</p>\n<!--\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata (EOF).\n-->\n\n<p><code>push()</code> メソッドはいくつかのデータを明示的に読み込みキューに挿入します。\nもし <code>null</code> と共に呼び出されると、それはデータが終了した (EOF) ことを伝えます。\n\n</p>\n<!--\nThis API is designed to be as flexible as possible.  For example,\nyou may be wrapping a lower-level source which has some sort of\npause/resume mechanism, and a data callback.  In those cases, you\ncould wrap the low-level source object by doing something like this:\n-->\n\n<p>この API は可能な限り柔軟に設計されています。\n例えば、ある種の中断／再開メカニズムとデータのコールバックを持つ、\nより低水準のデータソースをラップするかもしれません。\nそれらのケースでは、このように低水準のソースオブジェクトを\nラップすることができます。\n\n</p>\n<pre><code class="\"javascript\"">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n  var self = this;\n\n  // Every time there&#39;s data, we push it into the internal buffer.\n  this._source.ondata = function(chunk) {\n    // if push() returns false, then we need to stop reading from source\n    if (!self.push(chunk))\n      self._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signalling `null` chunk\n  this._source.onend = function() {\n    self.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Stream"
    }
  ]
}
