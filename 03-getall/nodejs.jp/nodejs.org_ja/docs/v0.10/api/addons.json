{
  "source": "doc/api/addons.markdown",
  "modules": [
    {
      "textRaw": "Addons",
      "name": "addons",
      "desc": "<!--\nAddons are dynamically linked shared objects. They can provide glue to C and\nC++ libraries. The API (at the moment) is rather complex, involving\nknowledge of several libraries:\n-->\n\n<p>アドオンは動的に共有オブジェクトをリンクします。\nそれらは、C や C++ のライブラリに接合点を提供します。\nAPI はいくつかのライブラリの知識が必要で、(現時点では) かなり複雑です。\n\n</p>\n<!--\n - V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\n   creating objects, calling functions, etc.  Documented mostly in the\n   `v8.h` header file (`deps/v8/include/v8.h` in the Node source\n   tree), which is also available\n   [online](http://izs.me/v8-docs/main.html).\n-->\n\n<ul>\n<li>V8 JavaScript は C++ のライブラリです。\nJavaScript のオブジェクト作成や関数呼び出し等のインタフェースに使用されます。\nドキュメントは主に、<code>v8.h</code> のヘッダファイル\n(Node のソースツリーの中の <code>deps/v8/include/v8.h</code>) に記されていますが、\n<a href="\"http://izs.me/v8-docs/main.html\"">オンライン</a> で参照することもできます。</li>\n</ul>\n<!--\n - [libuv](https://github.com/joyent/libuv), C event loop library.\n   Anytime one needs to wait for a file descriptor to become readable,\n   wait for a timer, or wait for a signal to be received one will need\n   to interface with libuv. That is, if you perform any I/O, libuv will\n   need to be used.\n-->\n\n<ul>\n<li><a href="\"https://github.com/joyent/libuv\"">libuv</a> は\nC のイベントループライブラリです。\nファイル記述子が読み取り可能になるのを待つとき、タイマーを待つとき、\nシグナルを受信するのを待つときはいつでも、\nlibv のインタフェースが必要になります。\nつまり、何らかの I/O 処理をすると必ず libuv を使う必要があるということです。</li>\n</ul>\n<!--\n - Internal Node libraries. Most importantly is the `node::ObjectWrap`\n   class which you will likely want to derive from.\n-->\n\n<ul>\n<li>Node の内部ライブラリ。\nもっとも重要なのは <code>node::ObjectWrap</code> クラスで、\nこのクラスから派生させることが多くなるでしょう。</li>\n</ul>\n<!--\n - Others. Look in `deps/` for what else is available.\n-->\n\n<ul>\n<li>その他。どのような物が利用できるかは <code>deps/</code> 以下を参照してさい。</li>\n</ul>\n<!--\nNode statically compiles all its dependencies into the executable.\nWhen compiling your module, you don't need to worry about linking to\nany of these libraries.\n-->\n\n<p>Node は全ての依存ライブラリを実行ファイルに静的にコンパイルします。\nモジュールのコンパイル時には、それらのリンクについて一切気にする必要は有りません。\n\n</p>\n<!--\nAll of the following examples are available for\n[download](https://github.com/rvagg/node-addon-examples) and may be\nused as a starting-point for your own Addon.\n-->\n\n<p>以下のサンプルの全ては\n<a href="\"https://github.com/rvagg/node-addon-examples\"">ダウンロード</a>\nから利用することができ、独自のアドオンの出発点になるでしょう。\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Hello world",
          "name": "hello_world",
          "desc": "<!--\nTo get started let's make a small Addon which is the C++ equivalent of\nthe following JavaScript code:\n-->\n\n<p>では、 以下の JavaScript コードと同じ様に動作する小さなアドオンを\nC++ で作成してみましょう。\n\n</p>\n<pre><code>module.exports.hello = function() { return &#39;world&#39;; };</code></pre>\n<!--\nFirst we create a file `hello.cc`:\n-->\n\n<p>最初に <code>hello.cc</code> というファイルを作成します:\n\n\n</p>\n<pre><code>#include &lt;node.h&gt;\n#include &lt;v8.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; Method(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(String::New(&quot;world&quot;));\n}\n\nvoid init(Handle&lt;Object&gt; exports) {\n  exports-&gt;Set(String::NewSymbol(&quot;hello&quot;),\n      FunctionTemplate::New(Method)-&gt;GetFunction());\n}\n\nNODE_MODULE(hello, init)</code></pre>\n<!--\nNote that all Node addons must export an initialization function:\n-->\n\n<p>全ての Node アドオンは初期化関数をエクスポートしなければならないことに\n注意してください。\n\n</p>\n<pre><code>void Initialize (Handle&lt;Object&gt; exports);\nNODE_MODULE(module_name, Initialize)</code></pre>\n<!--\nThere is no semi-colon after `NODE_MODULE` as it's not a function (see `node.h`).\n\nThe `module_name` needs to match the filename of the final binary (minus the\n.node suffix).\n\nThe source code needs to be built into `hello.node`, the binary Addon. To\ndo this we create a file called `binding.gyp` which describes the configuration\nto build your module in a JSON-like format. This file gets compiled by\n[node-gyp](https://github.com/TooTallNate/node-gyp).\n-->\n\n<p><code>NODE_MODULE</code> は関数ではないので、その後にセミコロンを付けてはいけません\n(<code>node.h</code> を参照してください)。\n\n</p>\n<p><code>module_name</code> は最終的なバイナリのファイル名 (拡張子 .node を除く)\nとマッチする必要があります。\n\n</p>\n<p>このソースコードは、<code>hello.node</code> というバイナリアドオンとしてビルドされる必要が有ります。\nそのために <code>binding.gyp</code> と呼ばれる、あなたのモジュールをビルドするための\n構成を JSON 的なフォーマットで記述したファイルを作成します。\nこのファイルは <a href="\"https://github.com/TooTallNate/node-gyp\"">node-gyp</a>\nによってコンパイルされます。\n\n</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;hello&quot;,\n      &quot;sources&quot;: [ &quot;hello.cc&quot; ]\n    }\n  ]\n}</code></pre>\n<!--\nThe next step is to generate the appropriate project build files for the\ncurrent platform. Use `node-gyp configure` for that.\n-->\n\n<p>次のステップは現在のプラットフォームに適したプロジェクトビルドファイルを\n生成することです。\n<code>node-gyp configure</code> を使います。\n\n</p>\n<!--\nNow you will have either a `Makefile` (on Unix platforms) or a `vcxproj` file\n(on Windows) in the `build/` directory. Next invoke the `node-gyp build`\ncommand.\n-->\n\n<p>これで、<code>Makefile</code> (Unix プラットフォームの場合)、または <code>vcxproj</code> ファイル\n(Windows の場合) が <code>build/</code> ディレクトリに作られます。\n次に <code>node-gyp build</code> コマンドを起動します。\n\n</p>\n<!--\nNow you have your compiled `.node` bindings file! The compiled bindings end up\nin `build/Release/`.\n-->\n\n<p>これでコンパイルされた <code>.node</code> バインディングファイルが作成されます！\nコンパイルされたバインディングファイルは <code>build/Release/</code> にあります。\n\n</p>\n<!--\nYou can now use the binary addon in a Node project `hello.js` by pointing `require` to\nthe recently built `hello.node` module:\n-->\n\n<p>ビルドされた <code>hello.node</code> モジュールを <code>require</code> で指定することにより、\nこのバイナリアドオンを Node プロジェクトの <code>hello.js</code> から利用することが\n可能になります。\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/hello&#39;);\n\nconsole.log(addon.hello()); // &#39;world&#39;</code></pre>\n<!--\nPlease see patterns below for further information or\n<https://github.com/arturadib/node-qt> for an example in production.\n-->\n\n<p>さらに詳しい情報については下記のパターンか、\n</p>\n<p><a href="\"https://github.com/arturadib/node-qt\"">https://github.com/arturadib/node-qt</a> を実際のプロダクトにおける\n例として参照してください。\n\n</p>\n",
          "type": "module",
          "displayName": "Hello world"
        },
        {
          "textRaw": "Addon patterns",
          "name": "addon_patterns",
          "desc": "<!--\nBelow are some addon patterns to help you get started. Consult the online\n[v8 reference](http://izs.me/v8-docs/main.html) for help with the various v8\ncalls, and v8's [Embedder's Guide](http://code.google.com/apis/v8/embed.html)\nfor an explanation of several concepts used such as handles, scopes,\nfunction templates, etc.\n-->\n\n<p>以下は初心者に役立つアドオンのパターンです。\nv8 の様々な API についてはオンラインの\n<a href="\"http://izs.me/v8-docs/main.html\"">v8 reference</a> が、\nそして ハンドルやスコープ、関数テンプレートなどいくつかの概念については\nv8 の <a href="\"http://code.google.com/apis/v8/embed.html\"">Embedder&#39;s Guide</a> が\n役に立つでしょう。\n\n</p>\n<!--\nIn order to use these examples you need to compile them using `node-gyp`.\nCreate the following `binding.gyp` file:\n-->\n\n<p>このサンプルを利用できるようにするには、<code>node-gyp</code> を使用して\nコンパイルする必要があります。\n以下の <code>binding.gyp</code> ファイルを作成します。\n\n</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [ &quot;addon.cc&quot; ]\n    }\n  ]\n}</code></pre>\n<!--\nIn cases where there is more than one `.cc` file, simply add the file name to the\n`sources` array, e.g.:\n-->\n\n<p>一つ以上の <code>.cc</code> ファイルがある場合は、単純に <code>sources</code> 配列にファイル名を\n加えるだけです。例:\n\n</p>\n<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>\n<!--\nNow that you have your `binding.gyp` ready, you can configure and build the\naddon:\n-->\n\n<p>これで <code>binding.gyp</code> の準備ができました。\nアドオンをコンフィギュアおよびビルドするには:\n\n</p>\n<pre><code>$ node-gyp configure build</code></pre>\n",
          "modules": [
            {
              "textRaw": "Function arguments",
              "name": "function_arguments",
              "desc": "<!--\nThe following pattern illustrates how to read arguments from JavaScript\nfunction calls and return a result. This is the main and only needed source\n`addon.cc`:\n-->\n\n<p>以下のパターンは JavaScript から呼び出された関数で引数を読み出したり、\n結果を返す方法を示します。これは <code>addon.cc</code> でのみ必要となります。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.Length() &lt; 2) {\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong number of arguments&quot;)));\n    return scope.Close(Undefined());\n  }\n\n  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong arguments&quot;)));\n    return scope.Close(Undefined());\n  }\n\n  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +\n      args[1]-&gt;NumberValue());\n  return scope.Close(num);\n}\n\nvoid Init(Handle&lt;Object&gt; exports) {\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\n      FunctionTemplate::New(Add)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nYou can test it with the following JavaScript snippet:\n-->\n\n<p>以下の JavaScript コード片でテストすることができます。\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\nconsole.log( &#39;This should be eight:&#39;, addon.add(3,5) );</code></pre>\n",
              "type": "module",
              "displayName": "Function arguments"
            },
            {
              "textRaw": "Callbacks",
              "name": "callbacks",
              "desc": "<!--\nYou can pass JavaScript functions to a C++ function and execute them from\nthere. Here's `addon.cc`:\n-->\n\n<p>JavaScript の関数を C++ の関数に渡してそこから呼び出すことができます。\nこれは <code>addon.cc</code> です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; RunCallback(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);\n  const unsigned argc = 1;\n  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };\n  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);\n\n  return scope.Close(Undefined());\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(RunCallback)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nNote that this example uses a two-argument form of `Init()` that receives\nthe full `module` object as the second argument. This allows the addon\nto completely overwrite `exports` with a single function instead of\nadding the function as a property of `exports`.\n-->\n\n<p>この例は二つの引数を取る形式の <code>Init()</code> を使用して、第2引数で完全な <code>module</code>\nオブジェクトを受け取っていることに注意してください。\nこれは、<code>exports</code> のプロパティとして関数を加える代わりに、アドオンが\n一つの関数で <code>exports</code> を完全に上書きすることを可能にします。\n\n</p>\n<!--\nTo test it run the following JavaScript snippet:\n-->\n\n<p>以下の JavaScript コード片でテストすることができます。\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\naddon(function(msg){\n  console.log(msg); // &#39;hello world&#39;\n});</code></pre>\n",
              "type": "module",
              "displayName": "Callbacks"
            },
            {
              "textRaw": "Object factory",
              "name": "object_factory",
              "desc": "<!--\nYou can create and return new objects from within a C++ function with this\n`addon.cc` pattern, which returns an object with property `msg` that echoes\nthe string passed to `createObject()`:\n-->\n\n<p>C++ 関数の中から新しいオブジェクトを作成して返すことができます。\n以下の <code>addon.cc</code> のパターンでは、<code>createObject()</code> に渡された文字列を\n反映する <code>msg</code> プロパティを持ったオブジェクトを返します。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;Object&gt; obj = Object::New();\n  obj-&gt;Set(String::NewSymbol(&quot;msg&quot;), args[0]-&gt;ToString());\n\n  return scope.Close(obj);\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test it in JavaScript:\n-->\n\n<p>テスト用の JavaScript:\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj1 = addon(&#39;hello&#39;);\nvar obj2 = addon(&#39;world&#39;);\nconsole.log(obj1.msg+&#39; &#39;+obj2.msg); // &#39;hello world&#39;</code></pre>\n",
              "type": "module",
              "displayName": "Object factory"
            },
            {
              "textRaw": "Function factory",
              "name": "function_factory",
              "desc": "<!--\nThis pattern illustrates how to create and return a JavaScript function that\nwraps a C++ function:\n-->\n\n<p>このパターンは C++ 関数をラップした JavaScript 関数を作成して返す方法を\n示します。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; MyFunction(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(String::New(&quot;hello world&quot;));\n}\n\nHandle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);\n  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();\n  fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // omit this to make it anonymous\n\n  return scope.Close(fn);\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test:\n-->\n\n<p>テスト:\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\nvar fn = addon();\nconsole.log(fn()); // &#39;hello world&#39;</code></pre>\n",
              "type": "module",
              "displayName": "Function factory"
            },
            {
              "textRaw": "Wrapping C++ objects",
              "name": "wrapping_c++_objects",
              "desc": "<!--\nHere we will create a wrapper for a C++ object/class `MyObject` that can be\ninstantiated in JavaScript through the `new` operator. First prepare the main\nmodule `addon.cc`:\n-->\n\n<p>ここでは、\nC++ オブジェクト／クラスをラップし、JavaScript から new 演算子を使って\nインスタンス化できる <code>MyObject</code> を作成します。\n最初にメインモジュール <code>addon.cc</code> を準備します:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nvoid InitAll(Handle&lt;Object&gt; exports) {\n  MyObject::Init(exports);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nThen in `myobject.h` make your wrapper inherit from `node::ObjectWrap`:\n-->\n\n<p>次に、<code>node::ObjectWrap</code> を継承したラッパーを <code>myobject.h</code> に作成します。\n\n</p>\n<pre><code>#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Handle&lt;v8::Object&gt; exports);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nAnd in `myobject.cc` implement the various methods that you want to expose.\nHere we expose the method `plusOne` by adding it to the constructor's\nprototype:\n-->\n\n<p>公開したい様々なメソッドを <code>myobject.cc</code> に実装します。\nここでは、コンストラクタに渡された値に加算する <code>plusOne</code> を公開しています:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Handle&lt;Object&gt; exports) {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  // Prototype\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n  exports-&gt;Set(String::NewSymbol(&quot;MyObject&quot;), constructor);\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\n  obj-&gt;value_ += 1;\n\n  return scope.Close(Number::New(obj-&gt;value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj = new addon.MyObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13</code></pre>\n",
              "type": "module",
              "displayName": "Wrapping C++ objects"
            },
            {
              "textRaw": "Factory of wrapped objects",
              "name": "factory_of_wrapped_objects",
              "desc": "<!--\nThis is useful when you want to be able to create native objects without\nexplicitly instantiating them with the `new` operator in JavaScript, e.g.\n-->\n\n<p>JavaScript の <code>new</code> 演算子で明示的にインスタンス化することなく、\nネイティブオブジェクトを作成できるようにしたい場合に便利です。例:\n\n</p>\n<pre><code>var obj = addon.createObject();\n// instead of:\n// var obj = new addon.Object();</code></pre>\n<!--\nLet's register our `createObject` method in `addon.cc`:\n-->\n\n<p>createObject<code> を </code>addon.cc` に登録しましょう:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nvoid InitAll(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  MyObject::Init();\n\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nIn `myobject.h` we now introduce the static method `NewInstance` that takes\ncare of instantiating the object (i.e. it does the job of `new` in JavaScript):\n-->\n\n<p><code>myobject.h</code> にオブジェクトを生成する static メソッド <code>NewInstance</code> を\n導入しましょう (すなわち，それが JavaScript 内の <code>new</code> の働きをします)。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation is similar to the above in `myobject.cc`:\n-->\n\n<p>実装は前述の <code>myobject.cc</code> と同様です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  // Prototype\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}\n\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\n  obj-&gt;value_ += 1;\n\n  return scope.Close(Number::New(obj-&gt;value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var createObject = require(&#39;./build/Release/addon&#39;);\n\nvar obj = createObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13\n\nvar obj2 = createObject(20);\nconsole.log( obj2.plusOne() ); // 21\nconsole.log( obj2.plusOne() ); // 22\nconsole.log( obj2.plusOne() ); // 23</code></pre>\n",
              "type": "module",
              "displayName": "Factory of wrapped objects"
            },
            {
              "textRaw": "Passing wrapped objects around",
              "name": "passing_wrapped_objects_around",
              "desc": "<!--\nIn addition to wrapping and returning C++ objects, you can pass them around\nby unwrapping them with Node's `node::ObjectWrap::Unwrap` helper function.\nIn the following `addon.cc` we introduce a function `add()` that can take on two\n`MyObject` objects:\n-->\n\n<p>C++ オブジェクトをラップして返すことに加えて、Node が提供するヘルパ関数\n<code>node::ObjectWrap::Unwrap</code> を使用してアンラップすることもできます。\n以下の <code>addon.cc</code> では、二つの <code>MyObject</code> オブジェクトを受け取る <code>add()</code>\n関数を導入します:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[0]-&gt;ToObject());\n  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[1]-&gt;ToObject());\n\n  double sum = obj1-&gt;Value() + obj2-&gt;Value();\n  return scope.Close(Number::New(sum));\n}\n\nvoid InitAll(Handle&lt;Object&gt; exports) {\n  MyObject::Init();\n\n  exports-&gt;Set(String::NewSymbol(&quot;createObject&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\n      FunctionTemplate::New(Add)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nTo make things interesting we introduce a public method in `myobject.h` so we\ncan probe private values after unwrapping the object:\n-->\n\n<p>よりおもしろくするために、<code>myobject.h</code> にパブリックメソッドを導入しましょう。\nしたがって、アンラップされたオブジェクトのプライベート変数を調べることが\nできます。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\n  double Value() const { return value_; }\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation of `myobject.cc` is similar as before:\n-->\n\n<p><code>myobject.cc</code> の実装はこれまでと同様です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\n\nvar obj1 = addon.createObject(10);\nvar obj2 = addon.createObject(20);\nvar result = addon.add(obj1, obj2);\n\nconsole.log(result); // 30</code></pre>\n",
              "type": "module",
              "displayName": "Passing wrapped objects around"
            }
          ],
          "type": "module",
          "displayName": "Addon patterns"
        }
      ],
      "type": "module",
      "displayName": "Addons"
    }
  ]
}
